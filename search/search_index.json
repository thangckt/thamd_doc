{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"thamd Documentation","text":""},{"location":"#thamd","title":"<code>thamd</code>","text":"<p><code>thamd</code>: an OOP Python package for building models, pre-processing and post-processing data from Molecular Dynamics simulations.</p> <p>This package is developed and maintained by thangckt</p> <p></p>"},{"location":"#thamd--installation","title":"Installation","text":""},{"location":"#thamd--pip","title":"Pip","text":"<pre><code>pip install thamd\n</code></pre>"},{"location":"#thamd--conda","title":"Conda","text":"<pre><code>conda install -c conda-forge thamd\n</code></pre>"},{"location":"traj/","title":"Molecular dynamics trajectory","text":""},{"location":"traj/#thamd.traj","title":"<code>thamd.traj</code>","text":"<p>This module contains classes and functions to process molecular dynamics trajectories.</p>"},{"location":"traj/#thamd.traj.Frame","title":"<code>Frame(dump_file=None, data_file=None, atom_style='auto', pdb_file=None, xyz_file=None, from_df=None, box=None, box_angle=None)</code>","text":"<p>Create an Object for a single-FRAME of trajectories from MD simulation.</p> <p>This class create a data-object (single configuration) for the analysis of computing data from LAMMPS. The file formats implemented in this class</p> <p></p> <ul> <li>LAMMPS DATA Format</li> <li>LAMMPS DUMP Format</li> <li>PDB format</li> <li>XYZ format</li> </ul> <p>This class implemented several ways to create <code>Frame</code> object</p> <ul> <li>create an empty data object</li> <li>create_DATA object with input data</li> <li>read from DUMP file</li> <li>read from DATA file</li> <li>read frome PDB file</li> </ul> <p>Attributes:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>name of input file</p> </li> <li> <code>timestep</code>             (<code>int</code>)         \u2013          <p>the timestep of configuration</p> </li> <li> <code>box</code>             (<code>array</code>)         \u2013          <p>3x2 array, the box size</p> </li> <li> <code>box_angle</code>             (<code>array</code>)         \u2013          <p>1x3 array, the box angle</p> </li> <li> <code>atom</code>             (<code>DataFrame</code>)         \u2013          <p>DataFrame of per-atom values</p> </li> <li> <code>prop_key</code>             (<code>list</code>)         \u2013          <p>column-names of properties</p> </li> <li> <code>mass</code>             (<code>DataFrame</code>)         \u2013          <p>DataFrame of per-type masses</p> </li> <li> <code>FMTstr</code>             (<code>str</code>)         \u2013          <p>default format for float numbers, don't use %g because it will lost precision</p> </li> </ul> <p>Examples:</p> <pre><code>from thamd.traj  import Frame\n\nda = Frame()                        # empty object\nda = Frame(from_df=df)              # oject with input data\nda = Frame(dump_file='test.cfg')    # from DUMP file\nda = Frame(data_file='mydata.dat')  # from DATA file\nda = Frame(pdb_file='test.pdb')     # from PDB file\n</code></pre> Quote <p>[1]. Use chain mutator calls</p> <p>initilize the Frame object</p> <p>Parameters:</p> <ul> <li> <code>dump_file</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>filename of DUMP file.</p> </li> <li> <code>data_file</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>filename of DATA file.</p> </li> <li> <code>pdb_file</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>filename of PBD file.</p> </li> <li> <code>xyz_file</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>filename of XYZ file.</p> </li> <li> <code>from_df</code>             (<code>DataFrame</code>, default:                 <code>None</code> )         \u2013          <p>create FRAME from data.</p> </li> <li> <code>atom_style</code>             (<code>str</code>, default:                 <code>'auto'</code> )         \u2013          <p>atom_style of system. Only need when <code>data_file</code> is used. Possible values: 'atomic', 'molecular', 'charge', 'full', 'auto'</p> </li> <li> <code>box</code>             (<code>np.array list</code>, default:                 <code>None</code> )         \u2013          <p>Define simulation box. Only need when <code>from_df</code> is used.</p> </li> <li> <code>box_angle</code>             (<code>np.array list</code>, default:                 <code>None</code> )         \u2013          <p>Define angle of simulation box. Only need when <code>from_df</code> is used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>Frame</code> )        \u2013          <p>object of trajectories</p> </li> </ul> Note <p>Use mutator, so do not use self.* when define value</p>"},{"location":"traj/#thamd.traj.Frame.box","title":"<code>box = np.asarray([[0, 1], [0, 1], [0, 1]], dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.box_angle","title":"<code>box_angle = np.asarray([0, 0, 0], dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.prop_key","title":"<code>prop_key = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.general","title":"<code>general = pd.Series({'filename': 'md_frame', 'step': 0, 'fmt': '%.6f'})</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.atom","title":"<code>atom = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.mass","title":"<code>mass = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.pair_coeff","title":"<code>pair_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.bond_coeff","title":"<code>bond_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.angle_coeff","title":"<code>angle_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.dihedral_coeff","title":"<code>dihedral_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.improper_coeff","title":"<code>improper_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.bondBond_coeff","title":"<code>bondBond_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.bondAngle_coeff","title":"<code>bondAngle_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.middleBondTorsion_coeff","title":"<code>middleBondTorsion_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.endBondTorsion_coeff","title":"<code>endBondTorsion_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.angleTorsion_coeff","title":"<code>angleTorsion_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.angleAngleTorsion_coeff","title":"<code>angleAngleTorsion_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.bondBond13_coeff","title":"<code>bondBond13_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.angleAngle_coeff","title":"<code>angleAngle_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.bond","title":"<code>bond = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.angle","title":"<code>angle = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.dihedral","title":"<code>dihedral = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.improper","title":"<code>improper = None</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Frame.create_DATA","title":"<code>create_DATA(DataFrame, box=None, box_angle=None)</code>","text":"<p>The method to create new FRAME object with input data.</p> <p>Parameters:</p> <ul> <li> <code>DataFrame</code>             (<code>DataFrame</code>)         \u2013          <p>of input data</p> </li> <li> <code>box</code>             (<code>array</code>, default:                 <code>None</code> )         \u2013          <p>3x2 array, option to input boxSize.</p> </li> <li> <code>box_angle</code>             (<code>array</code>, default:                 <code>None</code> )         \u2013          <p>1x3 array, option to input box_angle.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>Frame</code> )        \u2013          <p>update Frame</p> </li> </ul> <p>Examples:</p> <pre><code>da = Frame()\nda.create_DATA(DataFrame=df)\n# or\nda = Frame(from_df=df)\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.read_DATA","title":"<code>read_DATA(filename, atom_style='auto')</code>","text":"<p>The method to create FRAME object by reading DATA file. The style of atomistic system.The format of \"data file\" depend on the definition of \"atom_style\". See list of atom_style format. Can be detected automatically, or explicitly setting         - atomic      : atom-ID atom-type x y z         - charge      : atom-ID atom-type q x y z         - molecular   : atom-ID molecule-ID atom-type x y z         - full        : atom-ID molecule-ID atom-type q x y z Full lammps_data format</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>name of input file</p> </li> <li> <code>atom_style</code>             (<code>str</code>, default:                 <code>'auto'</code> )         \u2013          <p>option to choose atom_style. Defaults to 'auto'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>    da = TrajFrame(data_file='mydata.dat')\n</code></pre> Note <p>imgFlag: is auto detected <pre><code>    np.char.split(C[index]).tolist()              return \"object\"\n    np.char.split(C[index]).tolist()              return list\n    np.char.split(C[index1:idx_vel]).tolist()     return list-of-lists (2d list)\n</code></pre></p>"},{"location":"traj/#thamd.traj.Frame.read_DUMP","title":"<code>read_DUMP(filename)</code>","text":"<p>The method to create FRAME object by reading DUMP file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>name of input file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>    da = TrajFrame()\n    da.read_DUMP(DataFrame=df)\n    # or\n    da = TrajFrame(dump_file='mydata.cfg')\n</code></pre> Note <p>use list comprehension in code to get better performance</p>"},{"location":"traj/#thamd.traj.Frame.write_DATA","title":"<code>write_DATA(filename, atom_style='atomic', ignore_vel=False, ignore_imgFlag=False, ignore_pair_coeff=False, comment_line='', FMTstr='%.6f')</code>","text":"<p>The method to write DATA file. DATA format</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>name of input file</p> </li> <li> <code>atom_style</code>             (<code>str</code>, default:                 <code>'atomic'</code> )         \u2013          <p>the style of atomistic system, can be 'atomic', 'charge', 'molecular', 'full' . Defaults to 'atomic'.</p> </li> <li> <code>ignore_vel</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>to write Velocity values.</p> </li> <li> <code>ignore_imgFlag</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>to write imgFlag tag.</p> </li> <li> <code>ignore_pair_coeff</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>ignore pair-coeff when write data.</p> </li> <li> <code>comment_line</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>comment on second line in DATA file. Defaults to ''.</p> </li> <li> <code>FMTstr</code>             (<code>str</code>, default:                 <code>'%.6f'</code> )         \u2013          <p>string format for output values. Defaults to None, mean use self._FMT</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>file</code> (            <code>obj</code> )        \u2013          <p>the DUMP file</p> </li> </ul> <p>Examples:</p> <pre><code>da.write_DATA('test.dat', atom_style='atomic', ignore_imgFlag=False, ignore_vel=False, FMT='%.4f')\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.write_DUMP","title":"<code>write_DUMP(filename, column=None, FMTstr=None)</code>","text":"<p>The method to write DUMP file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>name of input file</p> </li> <li> <code>column</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>list-of-str contains columns to be written. Defaults to None, mean all columns will be written</p> </li> <li> <code>FMTstr</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>string format for output values. Defaults to None, mean use self._FMT</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>file</code> (            <code>obj</code> )        \u2013          <p>the DUMP file</p> </li> </ul> <p>Examples:</p> <pre><code>da.write_DUMP('test.cfg', column=['id','type','x','y','z'], FMTstr='%.4f')\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.read_PDB","title":"<code>read_PDB(filename)</code>","text":"<p>The method to create FRAME object by reading PDB file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>name of input file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME record_name (str): atom_symbol (str): same as column 'type' in DUMP format residue_name (str): residue_id (int): chain (str): occupancy (float): beta (float):</p> </li> </ul> <p>Examples:</p> <pre><code>da = TrajFrame(pdb_file='mydata.pdb')\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.write_PDB","title":"<code>write_PDB(filename, writeBox=False)</code>","text":"<p>The method to write PDB file</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>name of input file</p> </li> <li> <code>writeBox</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>write box or not.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>file</code> (            <code>obj</code> )        \u2013          <p>the PDB file</p> </li> </ul> <p>Examples:</p> <pre><code>da.write_PDB('test.pdb')\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.read_XYZ","title":"<code>read_XYZ(filename)</code>","text":"<p>The method to create FRAME object by reading XYZ file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>name of input file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>da = TrajFrame(pdb_file='mydata.pdb')\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.write_XYZ","title":"<code>write_XYZ(filename, column=['X', 'xu', 'yu', 'zu'], FMTstr=None)</code>","text":"<p>The <code>method</code> to write XYZ file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>name of input file</p> </li> <li> <code>column</code>             (<code>list</code>, default:                 <code>['X', 'xu', 'yu', 'zu']</code> )         \u2013          <p>list-of-str contains columns to be written. Defaults to ['X','xu','yu','zu']</p> </li> <li> <code>FMTstr</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>string format for output values. Defaults to None, mean use self._FMT</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>file</code> (            <code>obj</code> )        \u2013          <p>the XYZ file</p> </li> </ul> <p>Examples:</p> <pre><code>da.write_XYZ('test.xyz')\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.combine_frame","title":"<code>combine_frame(TrajFrame, merge_type=False, alignment='comXYZ', shift_XYZ=None, separate_XYZ=None, merge_box=True, use_box='box1')</code>","text":"<p>The method to combine 2 Lammps Frames.</p> <p>Parameters:</p> <ul> <li> <code>TrajFrame</code>             (<code>TrajFrame Obj</code>)         \u2013          <p>an Object of TrajFrame</p> </li> <li> <code>merge_type</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>merge the same type in 2 TrajFrame.</p> </li> <li> <code>alignment</code>             (<code>str</code>, default:                 <code>'comXYZ'</code> )         \u2013          <p>choose how to align 2 frame. Defaults to 'comXYZ'. + 'comXYZ': align based on COM + 'minXYZ': align based on left corner + 'maxXYZ': align based on right corner</p> </li> <li> <code>shift_XYZ</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>shift a distance from COM aligment. Defaults to [0,0,0].</p> </li> <li> <code>separate_XYZ</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>Separate 2 frame with a specific value. Defaults to [0,0,0].</p> </li> <li> <code>merge_box</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>choose to merge box or not. Defaults to True.</p> </li> <li> <code>use_box</code>             (<code>str</code>, default:                 <code>'box1'</code> )         \u2013          <p>be used as the box size if merge_box=False. Defaults to 'box1'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>Update TrajFrame da1</p> </li> </ul> <p>Examples:</p> <pre><code>da1.combine_frame(da2)\n</code></pre> <p>Todo</p> <ul> <li>combine box_angle</li> </ul> Quote <p>[1]. Deep copy: https://stackoverflow.com/questions/3975376/understanding-dict-copy-shallow-or-deep/3975388#3975388</p>"},{"location":"traj/#thamd.traj.Frame.unwrap_coord_DATA","title":"<code>unwrap_coord_DATA(imgFlag=['x', 'y', 'z'], atom_types=[])</code>","text":"<p>The method to upwrap coords in DATA file.</p> <p>Parameters:</p> <ul> <li> <code>imgFlag</code>             (<code>list</code>, default:                 <code>['x', 'y', 'z']</code> )         \u2013          <p>image Flags in data file. Defaults to ['x','y','z'].</p> </li> <li> <code>atom_types</code>             (<code>list</code>, default:                 <code>[]</code> )         \u2013          <p>just unwrap some atom-types. Defaults to [], mean unwrap all-types.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME</p> </li> </ul> Note <p>cannot unwrap_coord_data if imgFlags are not available.</p>"},{"location":"traj/#thamd.traj.Frame.wrap_coords_DUMP","title":"<code>wrap_coords_DUMP(dim=[1, 1, 1], inplace=True)</code>","text":"<p>The method to flip coords over the center.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>choose the dimenstion to take flip. Defaults to [1,1,1].</p> </li> <li> <code>inplace</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>if <code>True</code> it will replace (or addd x y z columns). If <code>False</code> it will return xyz array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME</p> </li> </ul>"},{"location":"traj/#thamd.traj.Frame.flip_coords","title":"<code>flip_coords(dim=[1, 1, 1])</code>","text":"<p>The method to flip coords over the center.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>choose the dimenstion to take flip. Defaults to [1,1,1].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME</p> </li> </ul> TODOs <p>Remove pandas Warning.</p>"},{"location":"traj/#thamd.traj.Frame.replicate","title":"<code>replicate(dim=[1, 1, 1])</code>","text":"<p>The method to flip coords over the center.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>choose the dimenstion to take flip. Defaults to [1,1,1].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME</p> </li> </ul>"},{"location":"traj/#thamd.traj.Frame.scale_box","title":"<code>scale_box(scale=None, final=None, delta=None, remap=True)</code>","text":"<p>The method to change size of simulation box.</p> <p>Parameters:</p> <ul> <li> <code>scale</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>to set scale ratio on each dimension of the box. scale = [0.7, 0.7, None] : if one dimension is set \"None\" its length is not changed.</p> </li> <li> <code>final</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>to set final length on each dimension of the box.</p> </li> <li> <code>delta</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>to set amount of change on each dimension of the box.</p> </li> <li> <code>remap</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>remap atom coordinate. Default to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>da.scale_box(scale=[0.7, 0.7, None])\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.add_column","title":"<code>add_column(data, newColumn=None, replace=False)</code>","text":"<p>The method to add new columns to da.atom.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>pd.DataFrame pd.Series list</code>)         \u2013          <p>Nxm data of new columns</p> </li> <li> <code>newColumn</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>1xN list contains names of columns. Default to None, mean it will take columnNames from DataFrame</p> </li> <li> <code>replace</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>replace column if existed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>Update da.atom</p> </li> </ul> <p>Examples:</p> <pre><code>da.add_column(df, myColumn=['col1','col2'], replace=True)\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.delete_column","title":"<code>delete_column(delColumns)</code>","text":"<p>The method to delete columns from da.atom.</p> <p>Parameters:</p> <ul> <li> <code>delColumns</code>             (<code>list</code>)         \u2013          <p>1xN list contains names of columns to be deleted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>Update da.atom</p> </li> </ul> <p>Examples:</p> <pre><code>da.delete_column(delColumns=['col1','col2'])\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.set_mass","title":"<code>set_mass(element_dict)</code>","text":"<p>The method to set masses of atoms in system. Before use it, need to define element_dict with 2 keys: 'type', 'atom_symbol'     element_dict={'type': list_values, 'atom_symbol':list_values}</p> <p>Parameters:</p> <ul> <li> <code>element_dict</code>             (<code>dict</code>)         \u2013          <p>a dict to define atom-types and atom-symbols.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>Update da.atom</p> </li> </ul> <p>Examples:</p> <pre><code>da.set_mass(element_dict={'type':[1,2,3], 'atom_symbol':['C','H','N']})\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.change_atom_type","title":"<code>change_atom_type(old_type, new_type, save_old_type=True)</code>","text":"<p>The method to change types of atoms in system.</p> <p>Parameters:</p> <ul> <li> <code>old_type</code>             (<code>list</code>)         \u2013          <p>a list of old-types.</p> </li> <li> <code>new_type</code>             (<code>int</code>)         \u2013          <p>one new-type.</p> </li> <li> <code>save_old_type</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>to back up old types. Default to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>da.chage_atom_type([1,2,3], 2)\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.merge_atom_type","title":"<code>merge_atom_type(old_type, save_old_type=True)</code>","text":"<p>The method to merge types of atoms in system.</p> <p>Parameters:</p> <ul> <li> <code>old_type</code>             (<code>list</code>)         \u2013          <p>a list of old-types.</p> </li> <li> <code>save_old_type</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>to back up old types. Default to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>da.chage_atom_type([1,2,3], 2)\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.compute_mass","title":"<code>compute_mass(atom_types=[])</code>","text":"<p>The method to compute mass of selected atom_types.</p> <p>Parameters:</p> <ul> <li> <code>atom_types</code>             (<code>list</code>, default:                 <code>[]</code> )         \u2013          <p>atom-types to compute masses. Defaults to [], mean all-types.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>m</code> (            <code>float</code> )        \u2013          <p>total mass of selected atoms.</p> </li> </ul> <p>Examples:</p> <pre><code>da.compute_mass(atom_types=[2,3])\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.compute_wt_percent","title":"<code>compute_wt_percent(atom_types)</code>","text":"<p>The method to compute weight percentage of some atom_types.</p> <p>Parameters:</p> <ul> <li> <code>atom_types</code>             (<code>list</code>)         \u2013          <p>atom-types compute percentage of weight.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>wt</code> (            <code>float</code> )        \u2013          <p>weight percentage of chosen atoms.</p> </li> </ul> <p>Examples:</p> <pre><code>da.compute_wt_percent(atom_types=[2,3])\n</code></pre>"},{"location":"traj/#thamd.traj.Frame.compute_colvar_sph_harm","title":"<code>compute_colvar_sph_harm(l, kind='real', normalization='4pi', bound_cond=[1, 1, 1], cutoff_neighbor=None, k_neighbor=None, k_cutoff=20, keep_ref=False, calc_coord=False)</code>","text":"<p>Compute per-atom vector of spherical harmonics</p> <p>Parameters:</p> <ul> <li> <code>l</code>             (<code>int)         </code>)         \u2013          <p>degree of Spherical Harmonic</p> </li> <li> <code>form</code>             (<code> (str</code>)         \u2013          <p>form of return result. Possible <code>complex</code>/<code>real</code>. Default to <code>complex</code></p> </li> </ul>"},{"location":"traj/#thamd.traj.Frame.copy","title":"<code>copy()</code>","text":"<p>The method to make an indepedent copy of Frame Obj. Then, the change values of the fields of the new object, the old object should not be affected by that.</p> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>Frame</code> )        \u2013          <p>new Frame Obj.</p> </li> </ul> <p>Examples:</p> <pre><code>da1 = da.copy()\n</code></pre> Quote <p>[1]. \"shallow copying\" vs \"deep copying\": https://stackoverflow.com/questions/3975376/understanding-dict-copy-shallow-or-deep/3975388#3975388</p>"},{"location":"traj/#thamd.traj.Frame.check_exist","title":"<code>check_exist(atom_types=None, mass_types=None)</code>","text":"<p>The method to check whether something is existed in system or not.</p> <p>Parameters:</p> <ul> <li> <code>atom_types</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>list-of-int of atom-types. Default to None.</p> </li> <li> <code>mass_types</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>list-of-int of atom-types. Default to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mgs</code> (            <code>str</code> )        \u2013          <p>raise Message if error.</p> </li> </ul> <p>Examples:</p> <pre><code>da.isExist(atom_types=[2,3])\n</code></pre> Note <pre><code>set() also return unique values.\n</code></pre>"},{"location":"traj/#thamd.traj.Traj","title":"<code>Traj(**kwargs)</code>","text":"<p>Create an Object for a multi-FRAMEs of trajectories from MD simulation. - read frome XYZ file</p> <p>initilize the TrajFrame object</p> Note <p>Use mutator, so do not use self.* when define value</p>"},{"location":"traj/#thamd.traj.Traj.fmtSTR","title":"<code>fmtSTR = '%.6f'</code>  <code>instance-attribute</code>","text":""},{"location":"traj/#thamd.traj.Traj.readXYZ","title":"<code>readXYZ(filename)</code>","text":"<p>The method create Multi-FRAME object by reading XYZ file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>name of input file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>TrajFrame</code> )        \u2013          <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>da = io.TrajFrame(pdb_file='mydata.pdb')\n</code></pre>"},{"location":"utils/","title":"utils","text":""},{"location":"utils/#thamd.utils","title":"<code>thamd.utils</code>","text":""},{"location":"utils/#thamd.utils.compute_angle","title":"<code>compute_angle</code>","text":""},{"location":"utils/#thamd.utils.compute_angle.angle_vector2vectors","title":"<code>angle_vector2vectors(fixVector, arrayVectors, unit='rad')</code>","text":"<p>copmute angles between a vector with set of vectors</p>"},{"location":"utils/#thamd.utils.compute_distance","title":"<code>compute_distance</code>","text":""},{"location":"utils/#thamd.utils.compute_distance.dist2_point2points","title":"<code>dist2_point2points(point, points)</code>","text":"<p>Compute bond_len and postion_vetors from 1 point to a list of points</p> <p>Parameters:</p> <ul> <li> <code>point</code>             (<code>list array</code>)         \u2013          <p>coordinate of 1 point.</p> </li> <li> <code>points</code>             (<code>list array</code>)         \u2013          <p>2d-list of coordinates of points/point.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>pd.DataFrame constains distance and component of connecting vectors.</p> </li> </ul>"},{"location":"utils/#thamd.utils.compute_distance.dist2_points2line","title":"<code>dist2_points2line(points, line=[(0, 0, 0), (0, 0, 0)])</code>","text":"<p>Compute bond_len and postion_vetors from 1 point to a list of points Ref: https://stackoverflow.com/questions/39840030/distance-between-point-and-a-line-from-two-points</p> <p>Parameters:</p> <ul> <li> <code>points</code>             (<code>list array DataFrame</code>)         \u2013          <p>list of coordinates of points/point.</p> </li> <li> <code>line</code>             (<code>list array</code>, default:                 <code>[(0, 0, 0), (0, 0, 0)]</code> )         \u2013          <p>2d-array contains coordinates to define a line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>d</code> (            <code>float list</code> )        \u2013          <p>distances between points and a line.</p> </li> </ul>"},{"location":"utils/#thamd.utils.compute_distance.closest_points2line","title":"<code>closest_points2line(points, line=[(0, 0, 0), (0, 0, 0)], distance=0, Xbound=None, Ybound=None, Zbound=None)</code>","text":"<p>Find all points locate inside a checkin-distance \"dist\" from a line.</p> <p>Parameters:</p> <ul> <li> <code>points</code>             (<code>list array</code>)         \u2013          <p>list of coordinates of points/point.</p> </li> <li> <code>line</code>             (<code>list array</code>, default:                 <code>[(0, 0, 0), (0, 0, 0)]</code> )         \u2013          <p>[[x1,y1,z1], [x1,y2,z2]]: 2d-list contains coordinates to define a line.</p> </li> <li> <code>distance</code>             (<code>float</code>, default:                 <code>0</code> )         \u2013          <p>the checkin-distance.</p> </li> <li> <code>Xbound</code>             (<code>tuple</code>, default:                 <code>None</code> )         \u2013          <p>define the boundaries for checking. Xbound='line': use the lengths of lines as bounds. Xbound=None: extend to INF. Xbound = (xlo, xhi)</p> </li> <li> <code>Ybound</code>             (<code>tuple</code>, default:                 <code>None</code> )         \u2013          <p>define the boundaries for checking.</p> </li> <li> <code>Zbound</code>             (<code>tuple</code>, default:                 <code>None</code> )         \u2013          <p>define the boundaries for checking.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ds_idx</code> (            <code>Series</code> )        \u2013          <p>Series of indices of points within the checkin-distance</p> </li> </ul>"},{"location":"utils/#thamd.utils.compute_distance.closest_points2multilines","title":"<code>closest_points2multilines(points, multilines=[], distance=0, Xbound=None, Ybound=None, Zbound=None)</code>","text":"<p>Find all points locate inside a checkin-distance \"dist\" from multilines. The Bound is set as the line-lengths.</p> <p>Parameters:</p> <ul> <li> <code>points</code>             (<code>list array</code>)         \u2013          <p>list of coordinates of points/point.</p> </li> <li> <code>multilines</code>             (<code>list</code>, default:                 <code>[]</code> )         \u2013          <p>list of pair-points, each pair-point contains coordinates of 2 points to define a line used in 'closest_points2line'.</p> </li> <li> <code>distance</code>             (<code>float</code>, default:                 <code>0</code> )         \u2013          <p>the checkin-distance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ds_idx</code> (            <code>Series</code> )        \u2013          <p>Series of indices of points within the checkin-distance</p> </li> </ul>"},{"location":"utils/#thamd.utils.compute_tensor","title":"<code>compute_tensor</code>","text":""},{"location":"utils/#thamd.utils.compute_tensor.ke_tensor","title":"<code>ke_tensor(vel, mass, kb)</code>","text":"<p>Compute Kinetic Energy tensors, and Temp Args:         vel (array): Nx3 array of per-atom velocity         mass (array): Nx3 array of atomic mass         inUNIT (str): ['angstrom','ps','amu','eV'], outUNIT=['eV','K']</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Kinetic energy tensor, Kinetic scalar, Temperature scalar</p> </li> </ul>"},{"location":"utils/#thamd.utils.compute_tensor.stress_tensor","title":"<code>stress_tensor(per_atom_stress_tensor, atomic_volume, unitFac=1)</code>","text":"<p>Compute local pressure/stress Args:          per_atom_stress_tensor : Nx6 array of the per-atom stress tensor         atomVol    : Nx1 vector of atomVol         inUNIT=['bar','angstrom'], outUNIT=['bar'] \u2192 unitFac=1e-4 for ['GPa']  Returns:          pressure scalar         Stress tensor</p>"},{"location":"utils/#thamd.utils.curve_intersect","title":"<code>curve_intersect</code>","text":""},{"location":"utils/#thamd.utils.curve_intersect.curve_intersect_shapely","title":"<code>curve_intersect_shapely(line1, line2)</code>","text":"<p>find the intersection points between 2 lines Args:         line1 (array like): Nx2 arrays, contains data points of curve 1         line2 (array like): Nx2 arrays, contains data points of curve 2</p> <p>Returns:</p> <ul> <li> <code>Points</code> (            <code>array like</code> )        \u2013          <p>Nx2 arrays, contains data points of intersection points</p> </li> </ul>"},{"location":"utils/#thamd.utils.curve_intersect.curve_intersect_numpy","title":"<code>curve_intersect_numpy(curve1, curve2, degree=3, bounds=None)</code>","text":"<p>find the intersection points between 2 curves</p> <p>Parameters:</p> <ul> <li> <code>curve1</code>             (<code>array like</code>)         \u2013          <p>Nx2 arrays in form (x,y), contains data points of curve 1</p> </li> <li> <code>curve2</code>             (<code>array like</code>)         \u2013          <p>Nx2 arrays in form (x,y), contains data points of curve 2</p> </li> <li> <code>degree</code>             (<code>int</code>, default:                 <code>3</code> )         \u2013          <p>degree of polynomial function to fit the curve</p> </li> <li> <code>bounds</code>             (<code>tuple</code>, default:                 <code>None</code> )         \u2013          <p>(min, max) of x, to select points in bounds</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Points</code> (            <code>array like</code> )        \u2013          <p>Nx2 arrays, contains data points of intersection points</p> </li> </ul> <p>Refs: [1] http://t.ly/2_a-K</p>"},{"location":"utils/#thamd.utils.data","title":"<code>data</code>","text":"<p>atomic_mass in in [g/mol], (1u = 1g/mol = 1.66053904 \u00d7 10-27 kg = 1mu)         Ref atomic mass here: https://tinyurl.com/yzv2namz</p> <p>Note: this is no longer being used. Indstead, Use module conda-forge ele.</p>"},{"location":"utils/#thamd.utils.data.ATOMIC_MASS","title":"<code>ATOMIC_MASS = {'H': 1.00797, 'He': 4.0026, 'Li': 6.941, 'Be': 9.012183, 'B': 10.81, 'C': 12.011, 'N': 14.0067, 'O': 15.9994, 'F': 18.998403, 'Ne': 20.179, 'Na': 22.989769, 'Mg': 24.305, 'Al': 26.98154, 'Si': 28.0855, 'P': 30.97376, 'S': 32.06, 'Cl': 35.453, 'Ar': 39.948, 'K': 39.0983, 'Ca': 40.08, 'Sc': 44.9559, 'Ti': 47.9, 'V': 50.9415, 'Cr': 51.996, 'Mn': 54.93804, 'Fe': 55.847, 'Co': 58.9332, 'Ni': 58.7, 'Cu': 63.546, 'Zn': 65.38, 'Ga': 69.72, 'Ge': 72.59, 'As': 74.9216, 'Se': 78.96, 'Br': 79.904, 'Kr': 83.8, 'Rb': 85.467, 'Sr': 87.6, 'Y': 88.9058, 'Zr': 91.22, 'Nb': 92.9063, 'Mo': 95.9, 'Ru': 101.0, 'Rh': 102.9055, 'Pd': 106.4, 'Ag': 107.868, 'Cd': 112.41, 'In': 114.81, 'Sn': 118.71, 'Sb': 121.76, 'Te': 127.6, 'I': 126.9044, 'Xe': 131.29, 'Cs': 132.9054519, 'Ba': 137.32, 'La': 138.9054, 'Ce': 140.11, 'Pr': 140.9076, 'Nd': 144.24, 'Sm': 150.3, 'Eu': 151.96, 'Gd': 157.2, 'Tb': 158.9253, 'Dy': 162.5, 'Ho': 164.9303, 'Er': 167.25, 'Tm': 168.9342, 'Yb': 173.05, 'Lu': 174.966, 'Hf': 178.4, 'Ta': 180.9478, 'W': 183.8, 'Re': 186.2, 'Os': 190.2, 'Ir': 192.21, 'Pt': 195.08, 'Au': 196.96656, 'Hg': 200.59, 'Tl': 204.3, 'Pb': 207.0, 'Bi': 208.9804}</code>  <code>module-attribute</code>","text":""},{"location":"utils/#thamd.utils.detect_sign_change","title":"<code>detect_sign_change</code>","text":""},{"location":"utils/#thamd.utils.detect_sign_change.detect_sign_change","title":"<code>detect_sign_change(y, x=[])</code>","text":"<p>determine points where line y=y(x) change its sign * Compulsory inputs:          y: Nx1 arrays, contains dependent variable y         x: (Optinal) Nx1 arrays, contains independent variable x of line y(x) * Output:         idx: 1d array of indices where sign changes</p>"},{"location":"utils/#thamd.utils.fitting","title":"<code>fitting</code>","text":""},{"location":"utils/#thamd.utils.fitting.uncertainty_weighted_fit_linear","title":"<code>uncertainty_weighted_fit_linear(x, y, weight_y=None, sigma_y=None)</code>","text":"<p>Compute uncertainties in coefficients A and B of y = A + B*x from the weighted least square fitting. Args:     x,y (array): 1D array of x and y data     weight_y (array): 1D array of weight of y data. If None, weight_y = 1/sigma_y**2     sigma_y (array): 1D array of standard deviation of y data. Use this if weight_y is None.</p> <p>Returns:</p> <ul> <li> <code>par</code> (            <code>array</code> )        \u2013          <p>1D array of coefficients A and B</p> </li> <li> <code>err</code> (            <code>tuple</code> )        \u2013          <p>1D array (sigma_intercept, sigma_slope) of standard deviation of A and B</p> </li> </ul> References <ol> <li>Taylor_1997_An introduction to error analysis: the study of uncertainties in physical measurements, page 198.</li> <li>https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyfit.html</li> </ol>"},{"location":"utils/#thamd.utils.fitting.find_slope","title":"<code>find_slope(x, y)</code>","text":"<p>Compute slope of a linear relation using np.polyfit See also: 'np.polyval', <code>np.polyder</code>, <code>np.roots</code></p> <p>Parameters:</p> <ul> <li> <code>x</code>             (<code>list</code>)         \u2013          <p>a list/array of x value</p> </li> <li> <code>y</code>             (<code>list</code>)         \u2013          <p>a list/array of y value</p> </li> </ul> Return <p>slope (float): the slope to linear relation</p>"},{"location":"utils/#thamd.utils.fitting.find_roots","title":"<code>find_roots(x, y, order=1)</code>","text":"<p>find roots for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (<code>list</code>)         \u2013          <p>a list/array of x value</p> </li> <li> <code>y</code>             (<code>list</code>)         \u2013          <p>a list/array of y value</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>order of polynomial. Defaults to 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>roots</code> (            <code>list</code> )        \u2013          <p>list of roots</p> </li> </ul>"},{"location":"utils/#thamd.utils.fitting.find_extrema","title":"<code>find_extrema(x, y, order=2, retun_fit=False)</code>","text":"<p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (<code>list</code>)         \u2013          <p>a list/array of x value</p> </li> <li> <code>y</code>             (<code>list</code>)         \u2013          <p>a list/array of y value</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>2</code> )         \u2013          <p>order of polynomial. Defaults to 2.</p> </li> <li> <code>retun_fit</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>return fitted params. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (            <code>list</code> )        \u2013          <p>list of flex points.</p> </li> </ul>"},{"location":"utils/#thamd.utils.fitting.find_convergence","title":"<code>find_convergence(x, y, order=2, tol=0.0001, grid_size=0.001)</code>","text":"<p>y is a function of x, then find value of x that y converge</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (<code>list</code>)         \u2013          <p>a list/array of x value</p> </li> <li> <code>y</code>             (<code>list</code>)         \u2013          <p>a list/array of y value</p> </li> <li> <code>tol</code>             (<code>float</code>, default:                 <code>0.0001</code> )         \u2013          <p>tolerance. Defaults to 1e-4.</p> </li> <li> <code>grid_size</code>             (<code>float</code>, default:                 <code>0.001</code> )         \u2013          <p>set grid size of x if need to finer data. Defaults to 0.001.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>best_x</code> (            <code>float</code> )        \u2013          <p>found value of x</p> </li> </ul> Notes <p>Do not use <code>df['y_diff'] = df['y'].diff()</code>, since it depends on grid size.</p>"},{"location":"utils/#thamd.utils.grid_box","title":"<code>grid_box</code>","text":""},{"location":"utils/#thamd.utils.grid_box.grid_box_2d","title":"<code>grid_box_2d(points, box, plane='XY', mode='bin_number', grid_size=[20, 20])</code>","text":"<p>devide box into 2d grid, return list of atom-IDs in each slab and list of slab-centers * Input:          P          : Nx3 array contain positions of atoms         box        : simulation box         mode       : \"bin_number\" or \"bin_size\"         mode_value : corresponding 'Number-of-bins' or 'size-of-bin'         plane      : on which plane the box will be gridded * Output:          atomIDinCell : 1xBinNumber array of 1xM-vector, contain indices of atoms of each Cell         cellCenter   : 1xBinNumber array of scalar, is center of each slab</p>"},{"location":"utils/#thamd.utils.grid_box.grid_box_1d","title":"<code>grid_box_1d(points, box, axis='Z', mode='bin_number', grid_size=20)</code>","text":"<p>devide box into 1d slabs, return list of atom-IDs in each slab and list of slab-centers * Input:          P          : Nx3 array contain positions of atoms         box        : simulation box         mode       : \"bin_number\" or \"bin_size\"         mode_value : corresponding 'Number-of-bins' or 'size-of-bin'         axis       : on which axis the box will be slabbed * Output:          atomIDinCell : 1xBinNumber array of 1xM arrays, contain indices of atoms of each Slab, array of arrays         geoCenter    : 1xBinNumber array of scalar, is geometry center of each slab         massCenter   : 1xBinNumber array of scalar, is mass center of each slab</p>"},{"location":"utils/#thamd.utils.many_stuff","title":"<code>many_stuff</code>","text":""},{"location":"utils/#thamd.utils.many_stuff.memory_usage","title":"<code>memory_usage()</code>","text":"<p>return the memory usage in MB</p>"},{"location":"utils/#thamd.utils.many_stuff.natSorted","title":"<code>natSorted(mylist)</code>","text":"<p>https://stackoverflow.com/questions/4836710/is-there-a-built-in-function-for-string-natural-sort</p>"},{"location":"utils/#thamd.utils.many_stuff.float2str","title":"<code>float2str(floatnum, fmt='%.6f', rstrip_zeros=True)</code>","text":"<p>convert float number to str REF: https://stackoverflow.com/questions/44111169/remove-trailing-zeros-after-the-decimal-point-in-python</p> <p>Parameters:</p> <ul> <li> <code>floatnum</code>             (<code>float</code>)         \u2013          <p>float number</p> </li> <li> <code>fmt</code>             (<code>str</code>, default:                 <code>'%.6f'</code> )         \u2013          <p>format of the output string</p> </li> <li> <code>rstrip_zeros</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>whether to remove trailing zeros</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>s</code> (            <code>str</code> )        \u2013          <p>string of the float number</p> </li> </ul>"},{"location":"utils/#thamd.utils.many_stuff.split_list","title":"<code>split_list(a, n)</code>","text":"<p>Should use <code>np.array_split</code> instead Args:             a (list): list to be splitted             n (int): number of chunks     Returns:             generator: a generator of splitted list</p>"},{"location":"utils/#thamd.utils.many_stuff.find_nearest_value","title":"<code>find_nearest_value(array, value)</code>","text":""},{"location":"utils/#thamd.utils.row_operation","title":"<code>row_operation</code>","text":""},{"location":"utils/#thamd.utils.row_operation.unique_row","title":"<code>unique_row(X, tol_decimal=2)</code>","text":"<p>find match_indices &amp; mismatch_indices of arr(find_rows) in arr(X), return indices of X X, find_rows    : NxN numpy arrays tol_decimal : number of digits for round off input data</p>"},{"location":"utils/#thamd.utils.row_operation.match_row","title":"<code>match_row(X, find_rows, tol_decimal=2)</code>","text":"<p>find match_indices &amp; mismatch_indices of arr(find_rows) in arr(X), return indices of X X, find_rows    : NxN numpy arrays tol_decimal : number of digits for round off input data</p>"},{"location":"utils/#thamd.utils.row_operation.asvoid","title":"<code>asvoid(arr)</code>","text":"<p>Base on: https://stackoverflow.com/questions/38674027/find-the-row-indexes-of-several-values-in-a-numpy-array</p>"},{"location":"utils/#thamd.utils.string_index","title":"<code>string_index</code>","text":""},{"location":"utils/#thamd.utils.string_index.string_index","title":"<code>string_index(idx_list)</code>","text":"<p>groupSURF index by consecutive-series</p>"},{"location":"utils/#thamd.utils.unit","title":"<code>unit</code>","text":"<p>This module to convert unit of some physical properties pressure</p> <p>Consider to use this module: https://unyt.readthedocs.io/en/stable/usage.html</p>"},{"location":"utils/#thamd.utils.unit.pressure","title":"<code>pressure(key_word='all_key')</code>","text":"<p>convert unit of pressure Pa: Pascal atm: standard atmosphere at: technical atmosphere</p> <p>kgf/cm2 = kg/cm2 1 Pa = 1 N/m^2 1 kgf/cm2 = 1</p> <p>Parameters:</p> <ul> <li> <code>key_word</code>             (<code>str</code>, default:                 <code>'all_key'</code> )         \u2013          <p>a string to specify units to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>factor</code> (            <code>float</code> )        \u2013          <p>multiply factor of conversion </p> </li> </ul> <p>Examples:</p> <pre><code>key_word='Pa_atm': convert from Pa (Pascal) to atm (Standard atmosphere)\n</code></pre>"},{"location":"utils/#thamd.utils.unit.force","title":"<code>force(key_word='all_key')</code>","text":"<p>convert unit of force N: Newton kgf = m.g: kilogram-force (weight: one kilogram of mass in a 9.80665 m/s2 gravitational field) lbf: pound-force p: pond</p> <p>1 N = 1 J/m    (Work = Force.distance) 1 kcal = 4184 J = 4184 N.m = 4184.10^10 N.Angstrom 69.4786 pN = 1 kcal/mol Angstrom.     https://tinyurl.com/yb2gnlhc</p> <p>Parameters:</p> <ul> <li> <code>key_word</code>             (<code>str</code>, default:                 <code>'all_key'</code> )         \u2013          <p>a string to specify units to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>factor</code> (            <code>float</code> )        \u2013          <p>multiply factor of conversion</p> </li> </ul>"},{"location":"utils/#thamd.utils.unit.energy","title":"<code>energy(key_word='all_key')</code>","text":"<p>convert unit of energy J: Joule W.h: watt-hour cal: calorie (th) hp.h: horsepower hour eV: electron-volt</p> <p>1 J = 1 N.m    (Work = Force.distance) 1J = 1 W.s</p> <p>Parameters:</p> <ul> <li> <code>key_word</code>             (<code>str</code>, default:                 <code>'all_key'</code> )         \u2013          <p>a string to specify units to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>factor</code> (            <code>float</code> )        \u2013          <p>multiply factor of conversion </p> </li> </ul> <p>Notes         <pre><code>## convert eV to kcal/mol\neV2J = 1/unit_convert.energy('J_eV')\nJ2Jmol = unit_convert.constant('1/mol')\nkj2kcal = 1/unit_convert.energy('kcal/mol_kJ/mol')\neV2kcalmol = eV2J * J2Jmol * 1e-3 *kj2kcal\n</code></pre></p>"},{"location":"utils/#thamd.utils.unit.constant","title":"<code>constant(key_word='all_key')</code>","text":"<p>list of constants Na = 6.02214076e23  (=1/mol): Avogadro number</p> <ul> <li>Input:         - key_word='all_key'         Ex: key_word='Pa_atm': convert from Pa (Pascal) to atm (Standard atmosphere)</li> <li>Output:         factor: float, multiply factor of conversion</li> </ul>"},{"location":"utils/#thamd.utils.user_lmfit","title":"<code>user_lmfit</code>","text":""},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit","title":"<code>UserLmfit</code>","text":"<p>The class contains set of objective function of fitting use by LMFIT package NOTEs: - defined function followed the convection of LMFIT: the first argument of the function is taken as the independent variable, held in independent_vars, and the rest of the functions positional arguments (and, in certain cases, keyword arguments \u2013 see below) are used for Parameter names. https://lmfit.github.io/lmfit-py/model.html - This Class defines curve-forms that are not vailable in LMFIT's built-in models</p> <ul> <li> <p>Attributes:         swType       : (default='RATIONAL') Type of witching function,         r0, d0       : The r_0 parameter of the switching function</p> </li> <li> <p>Methods:         fFunc    : compute &amp; return value and derivation of sw function         fDmax    : estimate value of Dmax</p> </li> </ul> <p>Ex: func = thamd.CurveLib.Linear(x)</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.Linear","title":"<code>Linear(x, a0, a1)</code>","text":"<p>this func is available in LMFIT, just play as an example here</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.inverseTemperature","title":"<code>inverseTemperature(x, a, b)</code>","text":""},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.ExpDecay","title":"<code>ExpDecay(x, A, lambd)</code>","text":""},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.sizeEffect","title":"<code>sizeEffect(x, a, b)</code>","text":"<p>system size-dependence on term N^(\u2154</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.unNormalGaussian","title":"<code>unNormalGaussian(x, amp, cen, sig)</code>","text":"<p>The unNormalize Gaussian function</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.NormalGaussian","title":"<code>NormalGaussian(x, amp, cen, sig)</code>","text":"<p>The Normalize Gaussian function</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.sum_2unNormalGaussian","title":"<code>sum_2unNormalGaussian(x, amp1, amp2, cen1, cen2, sig1, sig2)</code>","text":"<p>The sum of 2 Gaussian function</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.sum_3unNormalGaussian","title":"<code>sum_3unNormalGaussian(x, amp1, amp2, amp3, cen1, cen2, cen3, sig1, sig2, sig3)</code>","text":"<p>The sum of 3 Gaussian function</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.sum_4unNormalGaussian","title":"<code>sum_4unNormalGaussian(x, amp1, amp2, amp3, amp4, cen1, cen2, cen3, cen4, sig1, sig2, sig3, sig4)</code>","text":"<p>The sum of 4 Gaussian function</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.sum_5unNormalGaussian","title":"<code>sum_5unNormalGaussian(x, amp1, amp2, amp3, amp4, amp5, cen1, cen2, cen3, cen4, cen5, sig1, sig2, sig3, sig4, sig5)</code>","text":"<p>The sum of 5 Gaussian function</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.sum_2NormalGaussian","title":"<code>sum_2NormalGaussian(x, amp1, amp2, cen1, cen2, sig1, sig2)</code>","text":"<p>The sum of 2 Gaussian function</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.sum_3NormalGaussian","title":"<code>sum_3NormalGaussian(x, amp1, amp2, amp3, cen1, cen2, cen3, sig1, sig2, sig3)</code>","text":"<p>The sum of 3 Gaussian function</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.sum_4NormalGaussian","title":"<code>sum_4NormalGaussian(x, amp1, amp2, amp3, amp4, cen1, cen2, cen3, cen4, sig1, sig2, sig3, sig4)</code>","text":"<p>The sum of 4 Gaussian function</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.sum_5NormalGaussian","title":"<code>sum_5NormalGaussian(x, amp1, amp2, amp3, amp4, amp5, cen1, cen2, cen3, cen4, cen5, sig1, sig2, sig3, sig4, sig5)</code>","text":"<p>The sum of 5 Gaussian function</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.DoseResp","title":"<code>DoseResp(x, A1=-3.3, A2=-2.9, LOGx0=480000, p=1.2)</code>","text":"<p>Dose-response curve with variable Hill slope given by parameter 'p'. Origin's Category: Pharmacology * Params:                 Names=A1,A2,LOGx0,p                 Meanings=bottom asymptote,top asymptote, center, hill slope Initiate params: pars = mod.make_params(A1=-3.3, A2=-2.9, LOGx0=480000, p=1.2)</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.BiDoseResp","title":"<code>BiDoseResp(x, A1=-3.3, A2=-2.9, LOGx01=175000, LOGx02=480000, h1=0.1, h2=0.2, p=0.5)</code>","text":"<p>Biphasic Dose Response Function, Origin's Category: Pharmacology * Params:                 Names=A1, A2, LOGx01, LOGx02, h1, h2, p                 Meanings=Bottom, Top, 1<sup>st</sup> EC50, 2<sup>nd</sup> EC50, slope1, slope2, proportion Initiate params: pars = mod.make_params(A1=0, A2=100, LOGx01=-8, LOGx02=-4, h1=0.8, h2=1.2, p=0.5)</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.Carreau","title":"<code>Carreau(x, A1=60, A2=3, t=3.0, a=2.2, n=0.3)</code>","text":"<p>Carreau-Yasuda model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates Origin's Category: Rheology * Params:                 Names = A1,A2,t,a,n    &gt;0         (lower bound)                 Meanings = zero shear viscosity,infinite shear viscosity,time constant,transition control factor,power index Initiate params: pars = mod.make_params(A1=-3.3, A2=-2.9, t=2.0, a=2.2, n=0.2)</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.Cross","title":"<code>Cross(x, A1=0.1, A2=3, t=1000, m=0.9)</code>","text":"<p>Cross model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates Origin's Category: Rheology * Params:                 Names = A1,A2,t,m      &gt;0         (lower bound)                 Meanings = zero shear viscosity,infinite shear viscosity,time constant,power index Initiate params: pars = mod.make_params(A1=0.1, A2=3, t=1000, m=0.9)</p>"},{"location":"utils/#thamd.utils.user_lmfit.UserLmfit.GammaCFD","title":"<code>GammaCFD(x, y0, A1, a, b)</code>","text":"<p>Gamma cumulative distribution function Origin's Category: Statistics * Params:                 Names = y0,A1,a,b          (A1,a,b &gt;0)                 Meanings = Offset,Amplitude,Shape,Scale Initiate params: pars = mod.make_params(A1=0.1, A2=3, t=1000, m=0.9)</p>"},{"location":"vis/","title":"vis","text":""},{"location":"vis/#thamd.vis","title":"<code>thamd.vis</code>","text":""},{"location":"vis/#thamd.vis.ovito_modifier","title":"<code>ovito_modifier</code>","text":""},{"location":"vis/#thamd.vis.ovito_modifier.scale_RGB","title":"<code>scale_RGB(RGB=(255, 255, 255))</code>","text":"<p>Function to convert RGB color code from scale 0-255 to scale 0-1.</p> <p>Parameters:</p> <ul> <li> <code>RGB</code>             (<code>tuple</code>, default:                 <code>(255, 255, 255)</code> )         \u2013          <p>RGB code in scale 0-255</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>rgb</code> (            <code>tuple</code> )        \u2013          <p>RGB code in scale 0-1</p> </li> </ul> <p>Examples:</p> <pre><code>rgb = scale_RGB((255,255,255)))\n</code></pre> Quote <ol> <li>rgb-values-to-0-to-1-scale</li> </ol>"},{"location":"vis/#thamd.vis.ovito_modifier.mod_set_prop_atom_name","title":"<code>mod_set_prop_atom_name(frame, data)</code>","text":"<p>Modifier to set atom names</p> <p>Examples:</p> <pre><code>from thamd.visual.ovito_modifier import mod_set_prop_atom_name\nfrom ovito.io import import_file\n\npipeline = import_file(\"test.cfg\")\npipeline.add_to_scene()\n## add mod\ndict_name = {'type_id':[1, 2], 'atom_name':['C', 'H']}\npipeline.modifiers.append(mod_set_prop_atom_name)\n</code></pre> Note <ul> <li>So far, can not a custom argument to modifier, see here. So we need to define a <code>global variable</code> before using this function     <pre><code>dict_name = {'type_id':(1, 2), 'atom_name':('C', 'H')}\n</code></pre></li> <li>Do not use 'return` in modifier</li> <li>the underscore notation mean modifiable version of the quantity in ovito</li> </ul> Quote <ol> <li>Pass custom args to modifier</li> <li>ovito.data.Property             - type.id, type.name, type.color, type.radius</li> </ol>"},{"location":"vis/#thamd.vis.ovito_modifier.mod_set_prop_atom_color_PMMAori","title":"<code>mod_set_prop_atom_color_PMMAori(frame, data)</code>","text":"<p>Modifier to assign atom colors based on atom_names.</p> <p>Examples:</p> <pre><code>from thamd.visual.ovito_modifier import mod_set_prop_atom_color_PMMAori\nfrom ovito.io import import_file\n\npipeline = import_file(\"test.cfg\")\npipeline.add_to_scene()\n## add mod\npipeline.modifiers.append(mod_set_prop_atom_color_PMMAori)\n</code></pre>"},{"location":"colvar/colvar/","title":"Collective Variables","text":""},{"location":"colvar/colvar/#thamd.colvar","title":"<code>thamd.colvar</code>","text":"<p>This module contains classes and functions to compute Order parameters, Collective variables,...</p>"},{"location":"colvar/colvar/#thamd.colvar.cv_CoordNum","title":"<code>cv_CoordNum</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.cv_CoordNum.coord_number","title":"<code>coord_number(Points, **kwargs)</code>","text":"<p>The Coordination is the size of input \"Points\", this function just weight it with a switching function * Compulsory Inputs: ** optional Inputs:         switchFunc=[1,1...,1] : Nx1 array, contain values of switching function s(Rj) (Rj is positions of atom j) * Output:         coord  : scalar, Order Parameter     Example: S = thamd.OrderPara.Coordination([1,0,0; 0,1,0], SW=sw) By Cao Thang, Aug 2020</p>"},{"location":"colvar/colvar/#thamd.colvar.cv_PairANGLE","title":"<code>cv_PairANGLE</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.cv_PairANGLE.PairANGLE","title":"<code>PairANGLE(Points, CENTER, SIGMA, **kwargs)</code>","text":"<p>Order Parameter based on pair functions of Angles in the first shell:</p> Agrs <p>Points   : Nx3 Matrix, contain bonding vectors between neighboring  atoms j and ref atom i CENTER=[pi/3, pi/2, 2*pi/3, pi] : list, centers of Gaussians SIGMA =[0.03,0.04,0.04,0.03]   : list, sigmas of Gaussians switchFunc=[1,1...,1] : Nx1 array, contain values of switching function s(Rj) (Rj is positions of atom j)</p> <p>Returns:</p> <ul> <li> <code>gamma</code> (            <code>float</code> )        \u2013          <p>Order Parameter</p> </li> </ul> <p>Examples:</p> <pre><code>S = thamd.OrderPara.FCCcubic([1,0,0; 0,1,0], SW=sw)\n</code></pre> Note <p>Require to best chose Rcut for Switching function</p> Quote <ol> <li>Gobbob et al., \"Nucleation of Molecular Crystals Driven by Relative Information Entropy\"</li> </ol>"},{"location":"colvar/colvar/#thamd.colvar.cv_Steinhardt","title":"<code>cv_Steinhardt</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.cv_Steinhardt.Ql_Steinhardt","title":"<code>Ql_Steinhardt(ql_i)</code>","text":"<p>compute origincal Stainhardt of l-th order * Input:         ql_i   : a vector of (2l+1) complex components, qlm(i) vector of atom i * Output:         Ql      : scalar value of l-th order Stainhardt parameter</p>"},{"location":"colvar/colvar/#thamd.colvar.cv_Steinhardt.Local_Ql_Steinhardt","title":"<code>Local_Ql_Steinhardt(ql_i, qlm_j, SW)</code>","text":"<p>compute Local Stainhardt of l-th order (modified Steinhardt as: 10.1021/acs.jctc.6b01073) * Input:         ql_i   : 1x(2l+1) array, vector of (2l+1) complex components, qlm(i) vector of atom i         qlm_j   : Nx(2l+1) array, rows are vectors of (2l+1) complex components, qlm(j) of all neighbors j of atom i * Output:         Local_Ql_i      : scalar value of l-th order Stainhardt parameter of atom i * PreRequire: compute ql_i complex vector for all atoms before this function can be used</p>"},{"location":"colvar/colvar/#thamd.colvar.cv_fccCUBIC","title":"<code>cv_fccCUBIC</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.cv_fccCUBIC.fccCUBIC","title":"<code>fccCUBIC(points, alpha=27, zDirect='001', switch_function=None)</code>","text":"<p>Function to Calculate FCC CUBIC parameters.</p> <p>By thangckt, Mar 2020</p> <p>Parameters:</p> <ul> <li> <code>points</code>             (<code>Nx3 np.array</code>)         \u2013          <p>array contains bonding vectors between neighboring  atoms j and ref atom i</p> </li> <li> <code>alpha</code>             (<code>int</code>, default:                 <code>27</code> )         \u2013          <p>coefficient of harmonic function. Default to 27.</p> </li> <li> <code>zDirect</code>             (<code>str</code>, default:                 <code>'001'</code> )         \u2013          <p>direction of Z-direction, available '001'  '110'  '111'. Default to '001'.</p> </li> <li> <code>switch_function</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>list contain values of switching function s(Rj) (Rj is positions of atom j). Default to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>param</code> (            <code>float</code> )        \u2013          <p>Order Parameter.</p> </li> </ul> <p>Examples:</p> <pre><code>S = thamd.colvar.fccCUBIC([1,0,0; 0,1,0], alpha=3, zDirect='001', switch_function=sw)\n</code></pre> Note <p>Must choose suitable Rcut for Switching function.</p>"},{"location":"colvar/colvar/#thamd.colvar.cv_localCRYSTALLINITY","title":"<code>cv_localCRYSTALLINITY</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.cv_localCRYSTALLINITY.localCRYSTALLINITY","title":"<code>localCRYSTALLINITY(points, g_vectors=(1, 0, 0), switch_function=None)</code>","text":"<p>Function to Calculate Order Parameter with multi_vectors K.</p> <p>By thangckt, Apr 2019</p> <p>Parameters:</p> <ul> <li> <code>points</code>             (<code>Nx3 np.array</code>)         \u2013          <p>array contains bonding vectors between neighboring  atoms j and ref atom i     g_vectors (tuple): 2d-tuple contains \"directions_vectors\" for g_vectors  (ex: ((4*pi/a)(1,0,0), (4*pi/a)(0,1,0)). The actual g_vectors will be computed in function. Default to ((1,0,0)).</p> </li> <li> <code>switch_function</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>list contain values of switching function s(Rj) (Rj is positions of atom j). Default to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>aveLC</code> (            <code>float</code> )        \u2013          <p>is average Order Parameter , tage over on input g_factors, 0 &lt;= LC &lt;=1</p> </li> <li> <code>LC</code> (            <code>list</code> )        \u2013          <p>list of real numbers, are Order Parameters corresponding to each g-vector 0 &lt;= LC &lt;=1</p> </li> <li> <code>S</code> (            <code>list</code> )        \u2013          <p>(not computed) Kx1 vetor of complex numbers, are Static Structure Factors corresponding to each g-vector</p> </li> </ul> <p>Examples:</p> <pre><code>S = thamd.colvar.localCRYSTALLINITY([1,0,0; 0,1,0], switch_function=sw, zDirect='001')\n</code></pre> Note <p>If multi g-vectors is input, then OrderPara is take by averaging over all g-vectors.</p>"},{"location":"colvar/colvar/#thamd.colvar.cv_localCRYSTALLINITY.compute_Gvectors_FCC","title":"<code>compute_Gvectors_FCC(g_directions=(1, 0, 0), lattice_constant=1.0, zDirect='001')</code>","text":"<p>Function to convert reciprocal vectors G to be used in <code>localCRYSTALLINITY</code>.</p> <p>Parameters:</p> <ul> <li> <code>g_directions</code>             (<code>tuple</code>, default:                 <code>(1, 0, 0)</code> )         \u2013          <p>2d-tuple contains \"directions_vectors\" for g_vectors  (ex: ((1,0,0), (0,1,0)). The actual g_vectors will be computed in function. Default to ((1,0,0)).</p> </li> <li> <code>lattice_constant</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>lattice constant of crystal. Default to 1.</p> </li> <li> <code>zDirect</code>             (<code>str</code>, default:                 <code>'001'</code> )         \u2013          <p>direction of Z-direction, available '001'  '110'  '111'. Default to '001'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>g_vectors</code> (            <code>tuple</code> )        \u2013          <p>2d-tuple contains g_vectors</p> </li> </ul>"},{"location":"colvar/colvar/#thamd.colvar.cv_slip_atom","title":"<code>cv_slip_atom</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.cv_slip_atom.slip_atom","title":"<code>slip_atom(points, d_ref, d_diff)</code>","text":"<p>Function to Calculate FCC CUBIC parameters.</p> <p>Parameters:</p> <ul> <li> <code>points</code>             (<code>Nx3 np.array</code>)         \u2013          <p>array contains bonding vectors between neighboring  atoms j and ref atom i</p> </li> <li> <code>d_ref</code>             (<code>float</code>)         \u2013          <p>reference distance.</p> </li> <li> <code>d_diff</code>             (<code>float</code>)         \u2013          <p>difference distance to referred as dislocation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>param</code> (            <code>float</code> )        \u2013          <p>Order Parameter.</p> </li> </ul> <p>Examples:</p> <pre><code>S = thamd.colvar.fccCUBIC([1,0,0; 0,1,0], alpha=3, zDirect='001', switch_function=sw)\n</code></pre> Note <p>Must choose suitable Rcut for Switching function.</p>"},{"location":"colvar/colvar/#thamd.colvar.find_neighbors","title":"<code>find_neighbors</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.find_neighbors.find_neighbors_gen","title":"<code>find_neighbors_gen(P, box, bound_cond=[1, 1, 1], cutoff_neighbor=None, k_neighbor=None, k_cutoff=20, keep_ref=False)</code>","text":"<p>find Nearest_Neighbors, return generator of Nearest_IDs, \"Nearest relative-Position vetors from atom i\" Ver 2: spatial.cKDTree</p> <p>thangckt, Sep 2019. Update: Aug 2022 to use generator</p> <p>Parameters:</p> <ul> <li> <code>P</code>             (<code>array</code>)         \u2013          <p>Nx3 array contain positions of atoms</p> </li> <li> <code>box</code>             (<code>array</code>)         \u2013          <p>simulation box</p> </li> <li> <code>bound_cond</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>boundary condition</p> </li> <li> <code>cutoff_neighbor</code>             (<code>float</code>, default:                 <code>None</code> )         \u2013          <p>find neighbors within a Cutoff.</p> </li> <li> <code>k_neighbor</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>find k nearest neighbors</p> </li> <li> <code>keep_ref</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>include referal-atom in result</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>obj</code> (            <code>generator</code> )        \u2013          <p>this output a GEN contains (Idx_neigh, Rij_vectors)</p> </li> </ul> <p>Examples:</p> <pre><code>GEN = colvar.find_neighbors_gen(P, box, bound_cond = [1, 1, 1], cutoff_neighbor=9, keep_ref=False)\n</code></pre> old version <pre><code>access items in generator with:\n        for Near_ID, Rij_vector in GEN:\n                print (Near_ID, Rij_vector)\n\n- Idx_neigh    : Nx1 list of Mx1-vectors, contain Image_IDs(id of the original atoms before make periodicity) of Nearest atoms\n- Rij_vectors : Nx1 list of Mx3-Matrices, contain Nearest Rij relative-Position vetors from Ref.atom i (Nearest Positions)\n</code></pre>"},{"location":"colvar/colvar/#thamd.colvar.find_neighbors.find_neighbors_list","title":"<code>find_neighbors_list(P, box, bound_cond=[1, 1, 1], cutoff_neighbor=None, k_neighbor=None, k_cutoff=20, keep_ref=False)</code>","text":"<p>find Nearest_Neighbors, return list of Nearest_IDs, \"Nearest relative-Position vetors from atom i\" Ver 2: spatial.cKDTree</p> <p>Parameters:</p> <ul> <li> <code>P</code>             (<code>array</code>)         \u2013          <p>Nx3 array contain positions of atoms</p> </li> <li> <code>box</code>             (<code>array</code>)         \u2013          <p>simulation box</p> </li> <li> <code>bound_cond</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>boundary condition</p> </li> <li> <code>cutoff_neighbor</code>             (<code>float</code>, default:                 <code>None</code> )         \u2013          <p>find neighbors within a Cutoff.</p> </li> <li> <code>k_neighbor</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>find k nearest neighbors</p> </li> <li> <code>keep_ref</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>include referal-atom in result</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Idx_neigh</code> (            <code>array</code> )        \u2013          <p>Nx1 list of Mx1-vectors, contain Image_IDs(id of the original atoms before make periodicity) of Nearest atoms</p> </li> <li> <code>Rij_vectors</code> (            <code>array</code> )        \u2013          <p>Nx1 list of Mx3-Matrices, contain Nearest Rij relative-Position vetors from Ref.atom i (Nearest Positions)</p> </li> </ul> <p>Examples:</p> <pre><code>Idx_neigh, Rij_vectors = colvar.find_neighbors_list(P, box, bound_cond = [1, 1, 1], cutoff_neighbor=9, keep_ref=False)\n</code></pre> Note <pre><code>    don't compute Rij_Bond to save memory\n    Rij_Bonds (np.array): Nx1 list of scalars, contain Rij_bonds from Ref.atom to Nearest_atoms (Nearest-bonds)\n</code></pre>"},{"location":"colvar/colvar/#thamd.colvar.sph_harmonics","title":"<code>sph_harmonics</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.sph_harmonics.yl_i","title":"<code>yl_i(l, Rij, SW=None, kind='real', normalization='4pi', deg=False)</code>","text":"<p>Compute vector of Spherical Harmonics for a set of point (ylm vector have (2l+1) components)</p> <p>Parameters:</p> <ul> <li> <code>l</code>             (<code>int)         </code>)         \u2013          <p>degree of Spherical Harmonic</p> </li> <li> <code>Rij</code>             (<code>array - like</code>)         \u2013          <p>Nx3 array contain Rij of nearest neighbors compute from atom i</p> </li> <li> <code>SW</code>             (<code> (array-like</code>, default:                 <code>None</code> )         \u2013          <p>Nx1 values of switching function. Default to 'None'</p> </li> <li> <code>kind</code>             (<code> (str</code>, default:                 <code>'real'</code> )         \u2013          <p>kind of return result. Possible <code>complex</code>/<code>real</code>. Default to <code>complex</code></p> </li> <li> <code>normalization</code>             (<code>str</code>, default:                 <code>'4pi'</code> )         \u2013          <p>'4pi', 'ortho', 'schmidt', or 'unnorm' for geodesy 4pi normalized, orthonormalized, Schmidt semi-normalized, or unnormalized spherical harmonic functions, respectively. Default to '4pi'</p> </li> <li> <code>deg</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, theta and phi are expressed in degrees. Default to <code>False</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>yl</code> (            <code>array - like</code> )        \u2013          <p>vector of (2l+1) components</p> </li> </ul> Note <pre><code>This functions used the function `spharm_lm()` from [pyshtools](https://shtools.github.io/SHTOOLS/pyspharm_lm.html)\n</code></pre> Quote <pre><code>1. [Visualizing the real forms of the spherical harmonics](https://scipython.com/blog/visualizing-the-real-forms-of-the-spherical-harmonics/)\n2. In `scipy.special.sph_harm` function the azimuthal coordinate, theta, comes before the polar coordinate, phi; anh may return complex number only\n</code></pre>"},{"location":"colvar/colvar/#thamd.colvar.switch_function","title":"<code>switch_function</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.RATIONAL","title":"<code>RATIONAL(r0, d0=0.0, n=6, m=12, dmax_tol=0.001)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>r0</code>             (<code>float</code>)         \u2013          <p>The r_0 parameter of the switching function</p> </li> <li> <code>d0</code>             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>The d_0 parameter of the switching function</p> </li> <li> <code>n</code>             (<code> (float</code>, default:                 <code>6</code> )         \u2013          <p>The n parameter of the switching function</p> </li> <li> <code>m</code>             (<code> (float</code>, default:                 <code>12</code> )         \u2013          <p>The m parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>object</code> )        \u2013          <p>Object of the switching function</p> </li> </ul> Note <p>Dmin != D0 D0, R0    : are the parameter of switching function Dmin, Dmax : are the bounds at which the switching take affect</p> <p>Examples:</p> <pre><code>sw = thamd.SwitchFunc.RATIONAL(r0=6.3, d0=0.0, n=10)\n</code></pre> <p>create some intiatial attributes...</p>"},{"location":"colvar/colvar/#thamd.colvar.switch_function.RATIONAL.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.RATIONAL.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.RATIONAL.n","title":"<code>n = n</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.RATIONAL.m","title":"<code>m = m</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.RATIONAL.name","title":"<code>name = 'RATIONAL'</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.RATIONAL.eval","title":"<code>eval(x, compute_der=False)</code>","text":"<p>compute &amp; return value and derivation of sw function Input x can be a scalar or a 1d numpy ndarray</p>"},{"location":"colvar/colvar/#thamd.colvar.switch_function.RATIONAL.dmax","title":"<code>dmax(dmax_tol)</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.HEAVISIDE","title":"<code>HEAVISIDE(r0)</code>","text":"<p>create some intiatial attributes...</p>"},{"location":"colvar/colvar/#thamd.colvar.switch_function.HEAVISIDE.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.HEAVISIDE.d0","title":"<code>d0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.HEAVISIDE.dmax","title":"<code>dmax = r0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.HEAVISIDE.name","title":"<code>name = 'HEAVISIDE'</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.HEAVISIDE.eval","title":"<code>eval(x, compute_der=False)</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.CUBIC","title":"<code>CUBIC(d0, dmax)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>d0</code>             (<code>float</code>)         \u2013          <p>The r_0 parameter of the switching function</p> </li> <li> <code>dmax</code>             (<code>float</code>)         \u2013          <p>The d_0 parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>object</code> )        \u2013          <p>Object of the switching function</p> </li> </ul> <p>Examples:</p> <pre><code>        sw = thamd.SwitchFunc.CUBIC(d0=0.0, dmax=2)\n</code></pre> <p>create some intiatial attributes...</p>"},{"location":"colvar/colvar/#thamd.colvar.switch_function.CUBIC.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.CUBIC.dmax","title":"<code>dmax = dmax</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.CUBIC.name","title":"<code>name = 'CUBIC'</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.CUBIC.eval","title":"<code>eval(x, compute_der=False)</code>","text":"<p>compute &amp; return value and derivation of sw function</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (<code>float or ndarray</code>)         \u2013          <p>input values</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>f</code> (            <code>float or ndarray</code> )        \u2013          <p>value of the switching function</p> </li> <li> <code>df</code> (            <code>(float or ndarray, optional)</code> )        \u2013          <p>value of the derivative of the switching function. Just return if <code>compute_der=True</code></p> </li> </ul>"},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP","title":"<code>SMAP(r0, a=10, b=20, d0=0, tol=0.0001)</code>","text":"<p>create some intiatial attributes...</p>"},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.name","title":"<code>name = 'SMAP'</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.a","title":"<code>a = a</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.b","title":"<code>b = b</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.tol","title":"<code>tol = tol</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.eval","title":"<code>eval(x, compute_der=False)</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.findDmax","title":"<code>findDmax(tol=None, upper_bound=100, gridSize=0.0001)</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.findDmin","title":"<code>findDmin(tol=None, lower_bound=None, gridSize=0.0001)</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.find_Dmin_Dmax","title":"<code>find_Dmin_Dmax(tol=None, gridSize=0.0001, upper_bound=50)</code>","text":"<p>find Dmin and Dmax of function based on given tolerance</p>"},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.estimate_ab","title":"<code>estimate_ab(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001)</code>","text":"<p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version employs <code>scipy.optimize.minimize</code></p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>             (<code>float</code>)         \u2013          <p>target Dmin</p> </li> <li> <code>target_Dmax</code>             (<code>float</code>)         \u2013          <p>target Dmax</p> </li> <li> <code>search_step</code>             (<code>float</code>)         \u2013          <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>             (<code>float</code>, default:                 <code>0.001</code> )         \u2013          <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>             (<code>int</code>)         \u2013          <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>             (<code>int</code>)         \u2013          <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (            <code>float</code> )        \u2013          <p>found A</p> </li> <li> <code>B</code> (            <code>float</code> )        \u2013          <p>found B</p> </li> </ul>"},{"location":"colvar/colvar/#thamd.colvar.switch_function.SMAP.estimate_ab_old_manual","title":"<code>estimate_ab_old_manual(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001, search_step=0.1)</code>","text":"<p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version use manual search.</p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>             (<code>float</code>)         \u2013          <p>target Dmin</p> </li> <li> <code>target_Dmax</code>             (<code>float</code>)         \u2013          <p>target Dmax</p> </li> <li> <code>search_step</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>             (<code>float</code>, default:                 <code>0.001</code> )         \u2013          <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>             (<code>int</code>)         \u2013          <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>             (<code>int</code>)         \u2013          <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (            <code>float</code> )        \u2013          <p>found A</p> </li> <li> <code>B</code> (            <code>float</code> )        \u2013          <p>found B</p> </li> </ul>"},{"location":"colvar/colvar/#thamd.colvar.voronoi_analysis","title":"<code>voronoi_analysis</code>","text":""},{"location":"colvar/colvar/#thamd.colvar.voronoi_analysis.Voro3D","title":"<code>Voro3D()</code>","text":"<p>Voro ++ library * Attributes:</p> <ul> <li>Methods:         fAtomicVol_Bulk    : return atomicVol, coord of bulk model         fAtomicVol_Plate   : return atomicVol, coord of plate model By Cao Thang, updated: Jan 2020</li> </ul>"},{"location":"colvar/colvar/#thamd.colvar.voronoi_analysis.Voro3D.fAtomicVol_Bulk_gen","title":"<code>fAtomicVol_Bulk_gen(P, box, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Bulk models * Input:         P        : Nx3 Matrix contain positions of atoms         box      : simulation box **Optional:         coord_number=False : compute coordiation number * Output:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p> gen2 = thamd.fAtomicVol_Bulk_gen(P, box, coord_number=False)   # gen2 = (tomicVol_i, cell_neighbor_i) <p>gen3 = thamd.fAtomicVol_Bulk_gen(P, box, coord_number=True)    # gen3 = (tomicVol_i, cell_neighbor_i, coord_i)</p>"},{"location":"colvar/colvar/#thamd.colvar.voronoi_analysis.Voro3D.fAtomicVol_Plate_gen","title":"<code>fAtomicVol_Plate_gen(P, box, bound_cond=(1, 1, 0), max_edge=3.1, surf_deep=15, virtual_surface=True, offset=False, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Plate models update Ver2: copy layer 2<sup>nd</sup> and 3<sup>rd</sup> to cover free surface, offset distance = inter-layer distance. So, no need to input offset value * Input:         P        : Nx3 Matrix contain positions of atoms         box   : simulation box</p> <p>**Optional:         bound_cond=(1, 1, 0)  : tuple of boundary condtions         max_edge=3.1 : value to to compute face-area = max_edge**2         surf_deep=15 : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory         virtual_surface=True  : apply virtual surface to cover real surface before compute Voronoi                 + offset=False: extract 2 layers near outmost layer, and use to cover surface, offset_distance is auto computed based on atomic arrangement                 + offset=true: extract 1 layer near outmost layer, and use to cover surface with offset_distance = offset value         coord_number=False : compute coordiation number * Output:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p>"},{"location":"colvar/colvar/#thamd.colvar.voronoi_analysis.Voro3D.fAtomicVol_Bulk","title":"<code>fAtomicVol_Bulk(P, box, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Bulk models * Input:         P        : Nx3 Matrix contain positions of atoms         box      : simulation box **Optional:         coord_number=False : compute coordiation number * Output:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p>"},{"location":"colvar/colvar/#thamd.colvar.voronoi_analysis.Voro3D.fAtomicVol_Plate","title":"<code>fAtomicVol_Plate(P, box, bound_cond=(1, 1, 0), max_edge=3.1, surf_deep=15, virtual_surface=True, offset=False, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Plate models update Ver2: copy layer 2<sup>nd</sup> and 3<sup>rd</sup> to cover free surface, offset distance = inter-layer distance. So, no need to input offset value * Input:         P        : Nx3 Matrix contain positions of atoms         box   : simulation box</p> <p>**Optional:         bound_cond=(1, 1, 0)  : tuple of boundary condtions         max_edge=3.1 : value to to compute face-area = max_edge**2         surf_deep=15 : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory         virtual_surface=True  : apply virtual surface to cover real surface before compute Voronoi                 + offset=False: extract 2 layers near outmost layer, and use to cover surface, offset_distance is auto computed based on atomic arrangement                 + offset=true: extract 1 layer near outmost layer, and use to cover surface with offset_distance = offset value         coord_number=False : compute coordiation number * Output:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p>"},{"location":"colvar/colvar/#thamd.colvar.voronoi_analysis.layer_extractor","title":"<code>layer_extractor(P, bound_cond=(1, 1, 0), layer_num=1, max_edge=3.0, surf_deep=15, method='max_face_perimeter')</code>","text":"<p>Extract atoms of outermost layers, based on Voronoi analysis * Input:           P   : Nx3 Matrix contain positions of atoms           bound_cond=(1, 1, 0)  : tuple of boundary condtions           layer_num   : number of Layers need to extract (layer_num=0 will extract all layers)           max_edge  : value to to compute face-area = max_edge**2           surf_deep : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory           method   : 'max_face_perimeter'  or   'max_face_area' * Output:         hiLayerIndex, loLayerIndex: list of lists (1xM index of atoms in each layer) By Cao Thang, Jan 2020</p>"},{"location":"colvar/colvar/#thamd.colvar.voronoi_analysis.surface_detect","title":"<code>surface_detect(P, bound_cond=(1, 1, 0), max_edge=3.0, surf_deep=15, method='max_face_perimeter')</code>","text":"<p>Extract atoms on free surface, are atoms have Voronoi with max(faceArea) &gt;= max_edge**2 Agrs:     P   : Nx3 Matrix contain positions of atoms     bound_cond=(1, 1, 0)  : tuple of boundary condtions     max_edge  : value to to compute face-area = max_edge**2     surf_deep : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory     method   : 'max_face_perimeter'  or   'max_face_area'</p> <p>Returns:</p> <ul> <li>         \u2013          <p>hiSurIndex, loSurIndex: 1xM array, index of surface atoms in the original input points</p> </li> </ul> Note <p>experimental choose: max_edge=0.73*latticeConst only 1 pair of surface is detect each time</p>"},{"location":"colvar/colvar/#thamd.colvar.fccCUBIC","title":"<code>thamd.colvar.fccCUBIC(points, alpha=27, zDirect='001', switch_function=None)</code>","text":"<p>Function to Calculate FCC CUBIC parameters.</p> <p>By thangckt, Mar 2020</p> <p>Parameters:</p> <ul> <li> <code>points</code>             (<code>Nx3 np.array</code>)         \u2013          <p>array contains bonding vectors between neighboring  atoms j and ref atom i</p> </li> <li> <code>alpha</code>             (<code>int</code>, default:                 <code>27</code> )         \u2013          <p>coefficient of harmonic function. Default to 27.</p> </li> <li> <code>zDirect</code>             (<code>str</code>, default:                 <code>'001'</code> )         \u2013          <p>direction of Z-direction, available '001'  '110'  '111'. Default to '001'.</p> </li> <li> <code>switch_function</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>list contain values of switching function s(Rj) (Rj is positions of atom j). Default to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>param</code> (            <code>float</code> )        \u2013          <p>Order Parameter.</p> </li> </ul> <p>Examples:</p> <pre><code>S = thamd.colvar.fccCUBIC([1,0,0; 0,1,0], alpha=3, zDirect='001', switch_function=sw)\n</code></pre> Note <p>Must choose suitable Rcut for Switching function.</p>"},{"location":"colvar/colvar/#thamd.colvar.localCRYSTALLINITY","title":"<code>thamd.colvar.localCRYSTALLINITY(points, g_vectors=(1, 0, 0), switch_function=None)</code>","text":"<p>Function to Calculate Order Parameter with multi_vectors K.</p> <p>By thangckt, Apr 2019</p> <p>Parameters:</p> <ul> <li> <code>points</code>             (<code>Nx3 np.array</code>)         \u2013          <p>array contains bonding vectors between neighboring  atoms j and ref atom i     g_vectors (tuple): 2d-tuple contains \"directions_vectors\" for g_vectors  (ex: ((4*pi/a)(1,0,0), (4*pi/a)(0,1,0)). The actual g_vectors will be computed in function. Default to ((1,0,0)).</p> </li> <li> <code>switch_function</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>list contain values of switching function s(Rj) (Rj is positions of atom j). Default to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>aveLC</code> (            <code>float</code> )        \u2013          <p>is average Order Parameter , tage over on input g_factors, 0 &lt;= LC &lt;=1</p> </li> <li> <code>LC</code> (            <code>list</code> )        \u2013          <p>list of real numbers, are Order Parameters corresponding to each g-vector 0 &lt;= LC &lt;=1</p> </li> <li> <code>S</code> (            <code>list</code> )        \u2013          <p>(not computed) Kx1 vetor of complex numbers, are Static Structure Factors corresponding to each g-vector</p> </li> </ul> <p>Examples:</p> <pre><code>S = thamd.colvar.localCRYSTALLINITY([1,0,0; 0,1,0], switch_function=sw, zDirect='001')\n</code></pre> Note <p>If multi g-vectors is input, then OrderPara is take by averaging over all g-vectors.</p>"},{"location":"colvar/colvar/#thamd.colvar.coord_number","title":"<code>thamd.colvar.coord_number(Points, **kwargs)</code>","text":"<p>The Coordination is the size of input \"Points\", this function just weight it with a switching function * Compulsory Inputs: ** optional Inputs:         switchFunc=[1,1...,1] : Nx1 array, contain values of switching function s(Rj) (Rj is positions of atom j) * Output:         coord  : scalar, Order Parameter     Example: S = thamd.OrderPara.Coordination([1,0,0; 0,1,0], SW=sw) By Cao Thang, Aug 2020</p>"},{"location":"colvar/colvar/#thamd.colvar.yl_i","title":"<code>thamd.colvar.yl_i(l, Rij, SW=None, kind='real', normalization='4pi', deg=False)</code>","text":"<p>Compute vector of Spherical Harmonics for a set of point (ylm vector have (2l+1) components)</p> <p>Parameters:</p> <ul> <li> <code>l</code>             (<code>int)         </code>)         \u2013          <p>degree of Spherical Harmonic</p> </li> <li> <code>Rij</code>             (<code>array - like</code>)         \u2013          <p>Nx3 array contain Rij of nearest neighbors compute from atom i</p> </li> <li> <code>SW</code>             (<code> (array-like</code>, default:                 <code>None</code> )         \u2013          <p>Nx1 values of switching function. Default to 'None'</p> </li> <li> <code>kind</code>             (<code> (str</code>, default:                 <code>'real'</code> )         \u2013          <p>kind of return result. Possible <code>complex</code>/<code>real</code>. Default to <code>complex</code></p> </li> <li> <code>normalization</code>             (<code>str</code>, default:                 <code>'4pi'</code> )         \u2013          <p>'4pi', 'ortho', 'schmidt', or 'unnorm' for geodesy 4pi normalized, orthonormalized, Schmidt semi-normalized, or unnormalized spherical harmonic functions, respectively. Default to '4pi'</p> </li> <li> <code>deg</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, theta and phi are expressed in degrees. Default to <code>False</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>yl</code> (            <code>array - like</code> )        \u2013          <p>vector of (2l+1) components</p> </li> </ul> Note <pre><code>This functions used the function `spharm_lm()` from [pyshtools](https://shtools.github.io/SHTOOLS/pyspharm_lm.html)\n</code></pre> Quote <pre><code>1. [Visualizing the real forms of the spherical harmonics](https://scipython.com/blog/visualizing-the-real-forms-of-the-spherical-harmonics/)\n2. In `scipy.special.sph_harm` function the azimuthal coordinate, theta, comes before the polar coordinate, phi; anh may return complex number only\n</code></pre>"},{"location":"colvar/find_neighbors/","title":"Find neighbors","text":""},{"location":"colvar/find_neighbors/#thamd.colvar.find_neighbors","title":"<code>thamd.colvar.find_neighbors</code>","text":""},{"location":"colvar/find_neighbors/#thamd.colvar.find_neighbors.find_neighbors_gen","title":"<code>find_neighbors_gen(P, box, bound_cond=[1, 1, 1], cutoff_neighbor=None, k_neighbor=None, k_cutoff=20, keep_ref=False)</code>","text":"<p>find Nearest_Neighbors, return generator of Nearest_IDs, \"Nearest relative-Position vetors from atom i\" Ver 2: spatial.cKDTree</p> <p>thangckt, Sep 2019. Update: Aug 2022 to use generator</p> <p>Parameters:</p> <ul> <li> <code>P</code>             (<code>array</code>)         \u2013          <p>Nx3 array contain positions of atoms</p> </li> <li> <code>box</code>             (<code>array</code>)         \u2013          <p>simulation box</p> </li> <li> <code>bound_cond</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>boundary condition</p> </li> <li> <code>cutoff_neighbor</code>             (<code>float</code>, default:                 <code>None</code> )         \u2013          <p>find neighbors within a Cutoff.</p> </li> <li> <code>k_neighbor</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>find k nearest neighbors</p> </li> <li> <code>keep_ref</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>include referal-atom in result</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>obj</code> (            <code>generator</code> )        \u2013          <p>this output a GEN contains (Idx_neigh, Rij_vectors)</p> </li> </ul> <p>Examples:</p> <pre><code>GEN = colvar.find_neighbors_gen(P, box, bound_cond = [1, 1, 1], cutoff_neighbor=9, keep_ref=False)\n</code></pre> old version <pre><code>access items in generator with:\n        for Near_ID, Rij_vector in GEN:\n                print (Near_ID, Rij_vector)\n\n- Idx_neigh    : Nx1 list of Mx1-vectors, contain Image_IDs(id of the original atoms before make periodicity) of Nearest atoms\n- Rij_vectors : Nx1 list of Mx3-Matrices, contain Nearest Rij relative-Position vetors from Ref.atom i (Nearest Positions)\n</code></pre>"},{"location":"colvar/find_neighbors/#thamd.colvar.find_neighbors.find_neighbors_list","title":"<code>find_neighbors_list(P, box, bound_cond=[1, 1, 1], cutoff_neighbor=None, k_neighbor=None, k_cutoff=20, keep_ref=False)</code>","text":"<p>find Nearest_Neighbors, return list of Nearest_IDs, \"Nearest relative-Position vetors from atom i\" Ver 2: spatial.cKDTree</p> <p>Parameters:</p> <ul> <li> <code>P</code>             (<code>array</code>)         \u2013          <p>Nx3 array contain positions of atoms</p> </li> <li> <code>box</code>             (<code>array</code>)         \u2013          <p>simulation box</p> </li> <li> <code>bound_cond</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>boundary condition</p> </li> <li> <code>cutoff_neighbor</code>             (<code>float</code>, default:                 <code>None</code> )         \u2013          <p>find neighbors within a Cutoff.</p> </li> <li> <code>k_neighbor</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>find k nearest neighbors</p> </li> <li> <code>keep_ref</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>include referal-atom in result</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Idx_neigh</code> (            <code>array</code> )        \u2013          <p>Nx1 list of Mx1-vectors, contain Image_IDs(id of the original atoms before make periodicity) of Nearest atoms</p> </li> <li> <code>Rij_vectors</code> (            <code>array</code> )        \u2013          <p>Nx1 list of Mx3-Matrices, contain Nearest Rij relative-Position vetors from Ref.atom i (Nearest Positions)</p> </li> </ul> <p>Examples:</p> <pre><code>Idx_neigh, Rij_vectors = colvar.find_neighbors_list(P, box, bound_cond = [1, 1, 1], cutoff_neighbor=9, keep_ref=False)\n</code></pre> Note <pre><code>    don't compute Rij_Bond to save memory\n    Rij_Bonds (np.array): Nx1 list of scalars, contain Rij_bonds from Ref.atom to Nearest_atoms (Nearest-bonds)\n</code></pre>"},{"location":"colvar/surface_extractor/","title":"Surface extractor","text":""},{"location":"colvar/surface_extractor/#thamd.colvar.layer_extractor","title":"<code>thamd.colvar.layer_extractor(P, bound_cond=(1, 1, 0), layer_num=1, max_edge=3.0, surf_deep=15, method='max_face_perimeter')</code>","text":"<p>Extract atoms of outermost layers, based on Voronoi analysis * Input:           P   : Nx3 Matrix contain positions of atoms           bound_cond=(1, 1, 0)  : tuple of boundary condtions           layer_num   : number of Layers need to extract (layer_num=0 will extract all layers)           max_edge  : value to to compute face-area = max_edge**2           surf_deep : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory           method   : 'max_face_perimeter'  or   'max_face_area' * Output:         hiLayerIndex, loLayerIndex: list of lists (1xM index of atoms in each layer) By Cao Thang, Jan 2020</p>"},{"location":"colvar/surface_extractor/#thamd.colvar.surface_detect","title":"<code>thamd.colvar.surface_detect(P, bound_cond=(1, 1, 0), max_edge=3.0, surf_deep=15, method='max_face_perimeter')</code>","text":"<p>Extract atoms on free surface, are atoms have Voronoi with max(faceArea) &gt;= max_edge**2 Agrs:     P   : Nx3 Matrix contain positions of atoms     bound_cond=(1, 1, 0)  : tuple of boundary condtions     max_edge  : value to to compute face-area = max_edge**2     surf_deep : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory     method   : 'max_face_perimeter'  or   'max_face_area'</p> <p>Returns:</p> <ul> <li>         \u2013          <p>hiSurIndex, loSurIndex: 1xM array, index of surface atoms in the original input points</p> </li> </ul> Note <p>experimental choose: max_edge=0.73*latticeConst only 1 pair of surface is detect each time</p>"},{"location":"colvar/switch_function/","title":"Switching Functions","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function","title":"<code>thamd.colvar.switch_function</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.RATIONAL","title":"<code>RATIONAL(r0, d0=0.0, n=6, m=12, dmax_tol=0.001)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>r0</code>             (<code>float</code>)         \u2013          <p>The r_0 parameter of the switching function</p> </li> <li> <code>d0</code>             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>The d_0 parameter of the switching function</p> </li> <li> <code>n</code>             (<code> (float</code>, default:                 <code>6</code> )         \u2013          <p>The n parameter of the switching function</p> </li> <li> <code>m</code>             (<code> (float</code>, default:                 <code>12</code> )         \u2013          <p>The m parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>object</code> )        \u2013          <p>Object of the switching function</p> </li> </ul> Note <p>Dmin != D0 D0, R0    : are the parameter of switching function Dmin, Dmax : are the bounds at which the switching take affect</p> <p>Examples:</p> <pre><code>sw = thamd.SwitchFunc.RATIONAL(r0=6.3, d0=0.0, n=10)\n</code></pre> <p>create some intiatial attributes...</p>"},{"location":"colvar/switch_function/#thamd.colvar.switch_function.RATIONAL.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.RATIONAL.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.RATIONAL.n","title":"<code>n = n</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.RATIONAL.m","title":"<code>m = m</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.RATIONAL.name","title":"<code>name = 'RATIONAL'</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.RATIONAL.eval","title":"<code>eval(x, compute_der=False)</code>","text":"<p>compute &amp; return value and derivation of sw function Input x can be a scalar or a 1d numpy ndarray</p>"},{"location":"colvar/switch_function/#thamd.colvar.switch_function.RATIONAL.dmax","title":"<code>dmax(dmax_tol)</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.HEAVISIDE","title":"<code>HEAVISIDE(r0)</code>","text":"<p>create some intiatial attributes...</p>"},{"location":"colvar/switch_function/#thamd.colvar.switch_function.HEAVISIDE.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.HEAVISIDE.d0","title":"<code>d0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.HEAVISIDE.dmax","title":"<code>dmax = r0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.HEAVISIDE.name","title":"<code>name = 'HEAVISIDE'</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.HEAVISIDE.eval","title":"<code>eval(x, compute_der=False)</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.CUBIC","title":"<code>CUBIC(d0, dmax)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>d0</code>             (<code>float</code>)         \u2013          <p>The r_0 parameter of the switching function</p> </li> <li> <code>dmax</code>             (<code>float</code>)         \u2013          <p>The d_0 parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>object</code> )        \u2013          <p>Object of the switching function</p> </li> </ul> <p>Examples:</p> <pre><code>        sw = thamd.SwitchFunc.CUBIC(d0=0.0, dmax=2)\n</code></pre> <p>create some intiatial attributes...</p>"},{"location":"colvar/switch_function/#thamd.colvar.switch_function.CUBIC.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.CUBIC.dmax","title":"<code>dmax = dmax</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.CUBIC.name","title":"<code>name = 'CUBIC'</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.CUBIC.eval","title":"<code>eval(x, compute_der=False)</code>","text":"<p>compute &amp; return value and derivation of sw function</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (<code>float or ndarray</code>)         \u2013          <p>input values</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>f</code> (            <code>float or ndarray</code> )        \u2013          <p>value of the switching function</p> </li> <li> <code>df</code> (            <code>(float or ndarray, optional)</code> )        \u2013          <p>value of the derivative of the switching function. Just return if <code>compute_der=True</code></p> </li> </ul>"},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP","title":"<code>SMAP(r0, a=10, b=20, d0=0, tol=0.0001)</code>","text":"<p>create some intiatial attributes...</p>"},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.name","title":"<code>name = 'SMAP'</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.a","title":"<code>a = a</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.b","title":"<code>b = b</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.tol","title":"<code>tol = tol</code>  <code>instance-attribute</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.eval","title":"<code>eval(x, compute_der=False)</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.findDmax","title":"<code>findDmax(tol=None, upper_bound=100, gridSize=0.0001)</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.findDmin","title":"<code>findDmin(tol=None, lower_bound=None, gridSize=0.0001)</code>","text":""},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.find_Dmin_Dmax","title":"<code>find_Dmin_Dmax(tol=None, gridSize=0.0001, upper_bound=50)</code>","text":"<p>find Dmin and Dmax of function based on given tolerance</p>"},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.estimate_ab","title":"<code>estimate_ab(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001)</code>","text":"<p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version employs <code>scipy.optimize.minimize</code></p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>             (<code>float</code>)         \u2013          <p>target Dmin</p> </li> <li> <code>target_Dmax</code>             (<code>float</code>)         \u2013          <p>target Dmax</p> </li> <li> <code>search_step</code>             (<code>float</code>)         \u2013          <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>             (<code>float</code>, default:                 <code>0.001</code> )         \u2013          <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>             (<code>int</code>)         \u2013          <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>             (<code>int</code>)         \u2013          <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (            <code>float</code> )        \u2013          <p>found A</p> </li> <li> <code>B</code> (            <code>float</code> )        \u2013          <p>found B</p> </li> </ul>"},{"location":"colvar/switch_function/#thamd.colvar.switch_function.SMAP.estimate_ab_old_manual","title":"<code>estimate_ab_old_manual(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001, search_step=0.1)</code>","text":"<p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version use manual search.</p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>             (<code>float</code>)         \u2013          <p>target Dmin</p> </li> <li> <code>target_Dmax</code>             (<code>float</code>)         \u2013          <p>target Dmax</p> </li> <li> <code>search_step</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>             (<code>float</code>, default:                 <code>0.001</code> )         \u2013          <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>             (<code>int</code>)         \u2013          <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>             (<code>int</code>)         \u2013          <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (            <code>float</code> )        \u2013          <p>found A</p> </li> <li> <code>B</code> (            <code>float</code> )        \u2013          <p>found B</p> </li> </ul>"},{"location":"colvar/voronoi_analysis/","title":"Voronoi Analysis","text":""},{"location":"colvar/voronoi_analysis/#thamd.colvar.Voro3D","title":"<code>thamd.colvar.Voro3D()</code>","text":"<p>Voro ++ library * Attributes:</p> <ul> <li>Methods:         fAtomicVol_Bulk    : return atomicVol, coord of bulk model         fAtomicVol_Plate   : return atomicVol, coord of plate model By Cao Thang, updated: Jan 2020</li> </ul>"},{"location":"colvar/voronoi_analysis/#thamd.colvar.Voro3D.fAtomicVol_Bulk_gen","title":"<code>fAtomicVol_Bulk_gen(P, box, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Bulk models * Input:         P        : Nx3 Matrix contain positions of atoms         box      : simulation box **Optional:         coord_number=False : compute coordiation number * Output:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p> gen2 = thamd.fAtomicVol_Bulk_gen(P, box, coord_number=False)   # gen2 = (tomicVol_i, cell_neighbor_i) <p>gen3 = thamd.fAtomicVol_Bulk_gen(P, box, coord_number=True)    # gen3 = (tomicVol_i, cell_neighbor_i, coord_i)</p>"},{"location":"colvar/voronoi_analysis/#thamd.colvar.Voro3D.fAtomicVol_Plate_gen","title":"<code>fAtomicVol_Plate_gen(P, box, bound_cond=(1, 1, 0), max_edge=3.1, surf_deep=15, virtual_surface=True, offset=False, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Plate models update Ver2: copy layer 2<sup>nd</sup> and 3<sup>rd</sup> to cover free surface, offset distance = inter-layer distance. So, no need to input offset value * Input:         P        : Nx3 Matrix contain positions of atoms         box   : simulation box</p> <p>**Optional:         bound_cond=(1, 1, 0)  : tuple of boundary condtions         max_edge=3.1 : value to to compute face-area = max_edge**2         surf_deep=15 : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory         virtual_surface=True  : apply virtual surface to cover real surface before compute Voronoi                 + offset=False: extract 2 layers near outmost layer, and use to cover surface, offset_distance is auto computed based on atomic arrangement                 + offset=true: extract 1 layer near outmost layer, and use to cover surface with offset_distance = offset value         coord_number=False : compute coordiation number * Output:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p>"},{"location":"colvar/voronoi_analysis/#thamd.colvar.Voro3D.fAtomicVol_Bulk","title":"<code>fAtomicVol_Bulk(P, box, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Bulk models * Input:         P        : Nx3 Matrix contain positions of atoms         box      : simulation box **Optional:         coord_number=False : compute coordiation number * Output:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p>"},{"location":"colvar/voronoi_analysis/#thamd.colvar.Voro3D.fAtomicVol_Plate","title":"<code>fAtomicVol_Plate(P, box, bound_cond=(1, 1, 0), max_edge=3.1, surf_deep=15, virtual_surface=True, offset=False, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Plate models update Ver2: copy layer 2<sup>nd</sup> and 3<sup>rd</sup> to cover free surface, offset distance = inter-layer distance. So, no need to input offset value * Input:         P        : Nx3 Matrix contain positions of atoms         box   : simulation box</p> <p>**Optional:         bound_cond=(1, 1, 0)  : tuple of boundary condtions         max_edge=3.1 : value to to compute face-area = max_edge**2         surf_deep=15 : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory         virtual_surface=True  : apply virtual surface to cover real surface before compute Voronoi                 + offset=False: extract 2 layers near outmost layer, and use to cover surface, offset_distance is auto computed based on atomic arrangement                 + offset=true: extract 1 layer near outmost layer, and use to cover surface with offset_distance = offset value         coord_number=False : compute coordiation number * Output:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p>"},{"location":"free_energy/TI_method/","title":"TI methods","text":""},{"location":"free_energy/TI_method/#thamd.free_energy.Helmholtz_excess_UF","title":"<code>thamd.free_energy.Helmholtz_excess_UF</code>","text":""},{"location":"free_energy/TI_method/#thamd.free_energy.Helmholtz_excess_UF.Helmholtz_excess_UF","title":"<code>Helmholtz_excess_UF(p, x)</code>","text":"<p>this func. is to compute the excess Helmholtz freeEnergy as Eq.(25) by R.Paula Leite 2016. J.Chem.Phys.145,no.19:194101. https://doi.org/10.1063/1.4967775.                         p  :           # UFM p-parameter                         x = b*rho  :   # adimensional variable, involved UFM-sigma parameter, rho in unit [1/A^3]</p> <ol> <li>the excess_Helmholtz free enegy in eV : (beta*Fexc)/N</li> </ol> <ol> <li>the pressure : beta*b*P</li> </ol>"},{"location":"free_energy/TI_method/#thamd.free_energy.AS_integration","title":"<code>thamd.free_energy.AS_integration(forwFile, backFile)</code>","text":"<p>Compute Free energy difference in TI method - Lambda integration along Adiabatic Switching path</p> <p>Parameters:</p> <ul> <li> <code>forwFile</code>             (<code>str</code>)         \u2013          <p>file name of forward integration (must contain 2 first columns are: dE, lambda)</p> </li> <li> <code>backFile</code>             (<code>str</code>)         \u2013          <p>file name of backward integration (must contain 2 first columns are: dE, lambda)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>W</code> (            <code>float</code> )        \u2013          <p>irreversible TI work</p> </li> <li> <code>Q</code> (            <code>float</code> )        \u2013          <p>dissipation</p> </li> </ul>"},{"location":"free_energy/TI_method/#thamd.free_energy.RS_integration","title":"<code>thamd.free_energy.RS_integration(forwFile, backFile, T0=0, F0=0, kB=kB)</code>","text":"<p>Compute Free energy difference in TI method - Lambda integration along Reversible Scaling path</p> <p>Parameters:</p> <ul> <li> <code>forwFile</code>             (<code>str</code>)         \u2013          <p>file name of forward integration (must contain 2 first columns are: dE, lambda)</p> </li> <li> <code>backFile</code>             (<code>str</code>)         \u2013          <p>file name of backward integration (must contain 2 first columns are: dE, lambda)</p> </li> <li> <code>T0</code>             (<code>float</code>, default:                 <code>0</code> )         \u2013          <p>reference temperature. Default is 0.</p> </li> <li> <code>F0</code>             (<code>float</code>, default:                 <code>0</code> )         \u2013          <p>free energy at reference temperature. Default is 0.</p> </li> <li> <code>kB</code>             (<code>float</code>, default:                 <code>kB</code> )         \u2013          <p>Boltzmann constant (chose unit to consist with F0). Default is kB in unit eV/K.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (            <code>array</code> )        \u2013          <p>temperature</p> </li> <li> <code>Ft</code> (            <code>array</code> )        \u2013          <p>free energy as a function of temperature.</p> </li> <li> <code>W</code> (            <code>array</code> )        \u2013          <p>cumulative work</p> </li> </ul>"},{"location":"free_energy/replica_MD_average/","title":"replica_MD_average","text":""},{"location":"free_energy/replica_MD_average/#thamd.free_energy.replica_MD_average","title":"<code>thamd.free_energy.replica_MD_average</code>","text":""},{"location":"free_energy/replica_MD_average/#thamd.free_energy.replica_MD_average.replica_MD_average","title":"<code>replica_MD_average(MD_out_files)</code>","text":"<p>compute Replica_MD_Average from output of MD. Requisites: 1. Replica_* files from separate MD simulations</p> <ul> <li>Inputs-Compulsory:          - MD_out_files: |<code>list</code>| of \"MDout_replica.txt\" files</li> <li>Outputs:          - logPD file: contains logPD-based MeanForce</li> <li>Usage:          thaFreeEnergy.replica_MD_average(MD_out_files)</li> </ul> <p>Cao Thang, Jul2020 (update: Sep 2021)</p>"},{"location":"free_energy/replica_SteerMD/","title":"replica_SteerMD","text":""},{"location":"free_energy/replica_SteerMD/#thamd.free_energy.replica_SteerMD","title":"<code>thamd.free_energy.replica_SteerMD(SteerMD_files, beta=1.0, engine='Lammps')</code>","text":"<p>compute Average Work from output of SteerMD. REf: [1]. https://github.com/sandeshkalantre/jarzynski/blob/master/code/Simulations%20on%20Harmonic%20Oscillator%20Model.ipynb         [2]. https://www.plumed.org/doc-v2.6/user-doc/html/belfast-5.html#belfast-5-work         [3] Exp-normalize trick: https://timvieira.github.io/blog/post/2014/02/11/exp-normalize-trick/</p> <p>Requisites: 1. Replica_* files from separate MD simulations</p> <pre><code>* Inputs-Compulsory: &lt;br&gt;\n    - SteerMD_files: |`list`| of \"SteerMD.txt\" files\n    - beta = 1.0/(TEMP*kB):  kB is Boltzmann constant (can be set to 1.0, regardless of kB unit)\n    - engine='LAMMPS'/'PLUMED'\n* Outputs: &lt;br&gt;\n    - aveSteerMD file: contains logPD-based MeanForce\n* Usage: &lt;br&gt;\n    thaFreeEnergy.replica_SteerMD_average(SteerMD_files)\n</code></pre> <p>Cao Thang, Jul2020 (update: Mar 2022)</p>"},{"location":"free_energy/replica_logPD_integration/","title":"replica_logPD_integration","text":""},{"location":"free_energy/replica_logPD_integration/#thamd.free_energy.replica_logPD_integration","title":"<code>thamd.free_energy.replica_logPD_integration</code>","text":""},{"location":"free_energy/replica_logPD_integration/#thamd.free_energy.replica_logPD_integration.replica_logPD_integration","title":"<code>replica_logPD_integration(logmfd_files, replica_files, beta=1.0)</code>","text":"<p>The function to compute LogPD-based MeanForce</p> <pre><code>        cumulative_trapezoid:np.float64 = cumulative_trapezoid,   # this to specify `type` for function `cumulative_trapezoid`\n        logMFD:pd.DataFrame = read_data.logMFD,\n        matrix_auto:pd.DataFrame = read_data.matrix_auto):\n</code></pre> <p>Parameters:</p> <ul> <li> <code>logmfd_files</code>             (<code>list</code>)         \u2013          <p>list of \"logmfd.out\" files</p> </li> <li> <code>replica_files</code>             (<code>list</code>)         \u2013          <p>list of \"replica.out\" files</p> </li> <li> <code>beta</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>kB is Boltzmann constant (can be set to 1.0, regardless of kB unit). Defaults to beta = 1.0/(TEMP*kB)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>file</code> (            <code>obj</code> )        \u2013          <p>contains logPD-based MeanForce</p> </li> </ul> <p>Examples:</p> <pre><code>free_energy.replica_logPD_intergration(logmfd_files, replica_files)\n</code></pre> <p>Requisites</p> <pre><code>1. Run logMFD simulations to produce \"replica_*/logmfd.out\" and \"replica_*/replica.out\"\n\n```\n&lt;logmfd.out&gt;\n1:iter_md, 2:Flog(t), \u2026, 6: X(t), 7: V(t), 8: Force(t)\n1   F(1), \u2026, X(1), V(1), Force(0)\n2   F(3), \u2026, X(2), V(2), Force(1)\n\n&lt;replica.out&gt;\niter_md, work, weight, cv\n1  work(1)   weight(1)  cv(0)\n2  work(2)   weight(2)  cv(1)\n```\n</code></pre> Note <pre><code>    About the printed values in &lt;replica.out&gt; and &lt;logmfd.out&gt; as in emails replied by Tetsuya Morishita. (check thangckt email)\n    Specify type of function `cumulative_trapezoid:np.float64` to be used in `numba`\n</code></pre> Refs: <pre><code>    [1].https://pubs.acs.org/doi/10.1021/acs.jctc.7b00252 Free Energy Reconstruction from Logarithmic Mean-Force Dynamics Using Multiple Nonequilibrium TrajectoriesFree\n    [2] Exp-normalize trick: https://timvieira.github.io/blog/post/2014/02/11/exp-normalize-trick/\n</code></pre> 2023 Apr <p>CV-value in <code>replica.out</code> and <code>logmfd.out</code> are the same, so don't need to shift value in <code>replica.out</code> as below: <pre><code>Force = [elem['CV1_force'].shift(-1) for elem in logmfd ]\n</code></pre></p>"},{"location":"io/","title":"File IO","text":""},{"location":"io/#thamd.io","title":"<code>thamd.io</code>","text":"<p>This module contains classes and functions to read/write data in various formats.</p>"},{"location":"io/#thamd.io.define_script","title":"<code>define_script</code>","text":"<p>This module contains functions to define some specific scripts.</p>"},{"location":"io/#thamd.io.define_script.FCCUBIC_script","title":"<code>FCCUBIC_script(a_fcc, zDirect, label='mcv', alpha=27, partialCompute=False, atoms='@mdatoms', atomsA=None, atomsB=None, options='')</code>","text":"<p>PLUMED script to compute FCCUBIC</p> <p>Parameters:</p> <ul> <li> <code>a_fcc</code>             (<code>float</code>)         \u2013          <p>Lattice constant of FCC crystal</p> </li> <li> <code>zDirect</code>             (<code>str</code>)         \u2013          <p>specify the z-direction of crystal</p> </li> <li> <code>label</code>             (<code>str</code>, default:                 <code>'mcv'</code> )         \u2013          <p>label of PLUMED command</p> </li> <li> <code>alpha</code>             (<code>int</code>, default:                 <code>27</code> )         \u2013          <p>ALPHA parameter to compute FCCUBIC colvar.</p> </li> <li> <code>atoms</code>             (<code>str</code>, default:                 <code>'@mdatoms'</code> )         \u2013          <p>specify atom-ids in computed group.</p> </li> <li> <code>partialCompute</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>compute for some atoms.</p> </li> <li> <code>atomsA</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>specify atom-ids in group A.</p> </li> <li> <code>atomsB</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>specify atom-ids in group B.</p> </li> <li> <code>options</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>add options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list</code> )        \u2013          <p>list of strings.</p> </li> </ul>"},{"location":"io/#thamd.io.define_script.LOCAL_CRYSTALINITY_script","title":"<code>LOCAL_CRYSTALINITY_script(a_fcc, zDirect, label='mcv', vectors=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], atoms='@mdatoms', options='')</code>","text":"<p>PLUMED script to compute LOCAL_CRYSTALINITY</p> <p>Parameters:</p> <ul> <li> <code>a_fcc</code>             (<code>float</code>)         \u2013          <p>Lattice constant of FCC crystal</p> </li> <li> <code>zDirect</code>             (<code>str</code>)         \u2013          <p>specify the z-direction of crystal</p> </li> <li> <code>label</code>             (<code>str</code>, default:                 <code>'mcv'</code> )         \u2013          <p>label of PLUMED command</p> </li> <li> <code>vectors</code>             (<code>list</code>, default:                 <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )         \u2013          <p>2xN list of lists, to specify directions of reciprocal vectors.</p> </li> <li> <code>atoms</code>             (<code>str</code>, default:                 <code>'@mdatoms'</code> )         \u2013          <p>specify atom-ids in computed group.</p> </li> <li> <code>options</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>add options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list</code> )        \u2013          <p>list of strings.</p> </li> </ul>"},{"location":"io/#thamd.io.define_script.LOGMFD_script","title":"<code>LOGMFD_script(ARG, FICT, FICT_MIN, FICT_MAX, TEMP, DELTA_T, INTERVAL, KAPPA, deltaF, deltaX, kB, label='mfd', FLOG=5000, MFDstat='VS')</code>","text":"<p>PLUMED script to compute LOGFMD</p> <p>Parameters:</p> <ul> <li> <code>ARG</code>             (<code>str</code>)         \u2013          <p>the scalar input for this action</p> </li> <li> <code>FICT</code>             (<code>float</code>)         \u2013          <p>The initial values of the fictitious dynamical variables</p> </li> <li> <code>FICT_MIN</code>             (<code>float</code>)         \u2013          <p>Boundaries of CV_space</p> </li> <li> <code>FICT_MAX</code>             (<code>float</code>)         \u2013          <p>Boundaries of CV_space</p> </li> <li> <code>TEMP</code>             (<code>float</code>)         \u2013          <p>Temperature of the fictitious dynamical variables</p> </li> <li> <code>DELTA_T</code>             (<code>float</code>)         \u2013          <p>Time step for the fictitious dynamical variables (MFD step)</p> </li> <li> <code>INTERVAL</code>             (<code>int</code>)         \u2013          <p>Period of MD steps ( Nm) to update fictitious dynamical variables</p> </li> <li> <code>KAPPA</code>             (<code>int</code>)         \u2013          <p>Spring constant of the harmonic restraining potential for the fictitious dynamical variables</p> </li> <li> <code>deltaF</code>             (<code>float</code>)         \u2013          <p>Energy Barrier to estimate ALPHA (Alpha parameter for LogMFD)</p> </li> <li> <code>deltaX</code>             (<code>float</code>)         \u2013          <p>CV distance at each MFDstep, to estimate MFICT, VFICT (mass &amp; velocity of fictitious dynamical variable)</p> </li> <li> <code>kB</code>             (<code>float</code>)         \u2013          <p>Boltzmann constant</p> </li> </ul> <pre><code>label (str): label of PLUMED command\n    FLOG (float): The initial free energy value in the LogMFD, initial F(X)\n    MFDstat (str): Type of thermostat for the fictitious dynamical variables. NVE, NVT, VS are available.\n</code></pre> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list</code> )        \u2013          <p>list of strings.</p> </li> </ul>"},{"location":"io/#thamd.io.path_tools","title":"<code>path_tools</code>","text":""},{"location":"io/#thamd.io.path_tools.search_path","title":"<code>search_path(search_key, recursive=True)</code>","text":"<p>search files/dirs with specific key</p> <p>Parameters:</p> <ul> <li> <code>search_key</code>             (<code>str</code>)         \u2013          <p>key to search</p> </li> <li> <code>recursive</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>search recursively. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>list-of-str (list): paths to the files/dirs</p> </li> </ul>"},{"location":"io/#thamd.io.path_tools.change_pathname","title":"<code>change_pathname(paths, oldString, newString, replace=False)</code>","text":"<p>change path names</p> <p>Parameters:</p> <ul> <li> <code>paths</code>             (<code>list - of - str</code>)         \u2013          <p>paths to the files/dirs</p> </li> <li> <code>oldString</code>             (<code>str</code>)         \u2013          <p>old string in path name</p> </li> <li> <code>newString</code>             (<code>str</code>)         \u2013          <p>new string in path name</p> </li> <li> <code>replace</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>replace the old path name if the new one exists. Defaults to False.</p> </li> </ul>"},{"location":"io/#thamd.io.read_block","title":"<code>read_block</code>","text":""},{"location":"io/#thamd.io.read_block.LmpLogFile","title":"<code>LmpLogFile(logfile=None)</code>","text":"<p>Create an Object of LOG file.</p> Note <pre><code>run 0 without data\n</code></pre> <p>Parameters:</p> <ul> <li> <code>logfile</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>file_name of LOG file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpLogFile</code> )        \u2013          <p>LmpLogFile object</p> </li> </ul>"},{"location":"io/#thamd.io.read_block.LmpLogFile.read_log","title":"<code>read_log(logfile)</code>","text":"<p>Read LAMMPS logfile Args:         logfile (str): input LOG file</p> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpLogFile</code> )        \u2013          <p>LmpLogFile object</p> </li> </ul>"},{"location":"io/#thamd.io.read_block.LmpRDF","title":"<code>LmpRDF(file_name)</code>","text":"<p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> <p>Attributes:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>file name</p> </li> <li> <code>frame</code>             (<code>DataFrame</code>)         \u2013          <p>3d pandas Frame (multi-row-index DataFrame)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>ReadRDF       </code>           \u2013            <p>read RDF file</p> </li> <li> <code>AverageRDF    </code>           \u2013            <p>the Average RDF</p> </li> </ul> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpAveChunk</code> )        \u2013          <p>LmpAveChunk object</p> </li> </ul> <p>Examples:</p> <pre><code>RDF = LmpAveChunk('rdf.txt')\n</code></pre>"},{"location":"io/#thamd.io.read_block.LmpRDF.read_RDF","title":"<code>read_RDF(file_name)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>input RDF file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpRDF</code> )        \u2013          <p>LmpRDF object</p> </li> </ul>"},{"location":"io/#thamd.io.read_block.LmpRDF.compute_AveRDF","title":"<code>compute_AveRDF()</code>","text":"<p>compute average of RDF over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>Average of RDF</p> </li> </ul>"},{"location":"io/#thamd.io.read_block.LmpAveChunk","title":"<code>LmpAveChunk(file_name)</code>","text":"<p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> <p>Attributes:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>file name.</p> </li> <li> <code>frame</code>             (<code>DataFrame</code>)         \u2013          <p>3d pandas Frame (multi-row-index DataFrame).</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>ReadRDF       </code>           \u2013            <p>read RDF file</p> </li> <li> <code>AverageRDF    </code>           \u2013            <p>the Average RDF</p> </li> </ul> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpAveChunk</code> )        \u2013          <p>LmpAveChunk object</p> </li> </ul> <p>Examples:</p> <pre><code>RDF = LmpAveChunk('LmpAveChunk.txt')\n</code></pre>"},{"location":"io/#thamd.io.read_block.LmpAveChunk.read_AveChunk","title":"<code>read_AveChunk(file_name)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>input RDF file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpAveChunk</code> )        \u2013          <p>LmpAveChunk object</p> </li> </ul>"},{"location":"io/#thamd.io.read_block.LmpAveChunk.compute_AveChunk","title":"<code>compute_AveChunk()</code>","text":"<p>compute average of RDF over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>Average of RDF</p> </li> </ul>"},{"location":"io/#thamd.io.read_block.PlumHistogram","title":"<code>PlumHistogram(file_name)</code>","text":"<p>Create an Object of DUMP file</p> <p>Methods:</p> <ul> <li> <code>read_histogram       </code>           \u2013            <p>read Histogram file</p> </li> <li> <code>average_histogram    </code>           \u2013            <p>the Average Histogram</p> </li> <li> <code>AreaHisto       </code>           \u2013            <p>Area under pdf curve</p> </li> <li> <code>find_tail</code>           \u2013            <p>find limit of histogram</p> </li> <li> <code>find_center</code>           \u2013            <p>find center of histogram</p> </li> </ul> <p>Examples:</p> <pre><code>RDF = thaFileType.PlumHistogram(file_name='myRDF.txt')\n</code></pre> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>PlumHistogram</code> )        \u2013          <p>PlumHistogram object</p> </li> </ul>"},{"location":"io/#thamd.io.read_block.PlumHistogram.read_histogram","title":"<code>read_histogram(file_name)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code> </code>)         \u2013          <p>input HISTOGRAM file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>PlumHistogram</code> )        \u2013          <p>update PlumHistogram object</p> </li> </ul>"},{"location":"io/#thamd.io.read_block.PlumHistogram.compute_average_histogram","title":"<code>compute_average_histogram()</code>","text":"<p>compute average of histogram over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>DataFrame of avergave histogram</p> </li> </ul>"},{"location":"io/#thamd.io.read_block.PlumHistogram.areaHisto","title":"<code>areaHisto()</code>","text":""},{"location":"io/#thamd.io.read_block.PlumHistogram.fit_std_gaussian","title":"<code>fit_std_gaussian()</code>","text":"<p>Fit the average-histogarm to Standard Gaussian function</p> <p>Returns:</p> <ul> <li> <code>amp, miu, sigma) (tuple</code>         \u2013          <p>parameters of Gaussian function</p> </li> </ul>"},{"location":"io/#thamd.io.read_block.PlumHistogram.find_tail","title":"<code>find_tail(tol=0.0001, gridSize=1e-06)</code>","text":"<p>Find tail of distribution function</p> <p>Parameters:</p> <ul> <li> <code>tol</code>             (<code>float</code>, default:                 <code>0.0001</code> )         \u2013          <p>tolerance</p> </li> <li> <code>gridSize</code>             (<code>float</code>, default:                 <code>1e-06</code> )         \u2013          <p>size of grid</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>left_tail</code> (            <code>float</code> )        \u2013          <p>limit on the left side</p> </li> <li> <code>right_tail</code> (            <code>float</code> )        \u2013          <p>limit on the right side</p> </li> </ul>"},{"location":"io/#thamd.io.read_block.PlumHistogram.find_center","title":"<code>find_center(gridSize=1e-06)</code>","text":"<p>Find tail of distribution function</p> <p>Parameters:</p> <ul> <li> <code>gridSize</code>             (<code>float</code>, default:                 <code>1e-06</code> )         \u2013          <p>size of grid</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Xcenter</code> (            <code>float</code> )        \u2013          <p>center of the distribution function</p> </li> </ul>"},{"location":"io/#thamd.io.read_data","title":"<code>read_data</code>","text":"<p>This module contains functions to read numeric data from various formats of TEXT files.</p>"},{"location":"io/#thamd.io.read_data.matrix_auto","title":"<code>matrix_auto(file_name, header_line=None, set_column_name=None, comment='#', read_note=False) -&gt; pd.DataFrame</code>","text":"<p>Function to read Data that number of values in each line are not equal, ex: p2p binance (missing values) This cannot be read by Numpy, Pandas,...</p> <p>The names of columns are exatract based on <code>set_column_name</code> or <code>header_line</code>. If both <code>set_column_name</code> and <code>header_line</code> are not available, the default column's name is: 0 1 2...</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the text file.</p> </li> <li> <code>header_line</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>the lines to extract column-names. Defaults to None.</p> </li> <li> <code>set_column_name</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>Names of columns to extract. Defaults to None.</p> </li> <li> <code>comment</code>             (<code>str</code>, default:                 <code>'#'</code> )         \u2013          <p>comment-line mark. Defaults to \"#\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>pandas DataFrame</p> </li> </ul> Note <p>To return 2 lists from list comprehension, it is better (may faster) running 2 separated list comprehensions. <code>.strip()</code> function remove trailing and leading space in string.</p>"},{"location":"io/#thamd.io.read_data.matrix","title":"<code>matrix(file_name, header_line=None, set_column_name=None, usecols=None)</code>","text":"<p>Function to read Data that is as a regular matrix. The names of columns are exatract based on <code>set_column_name</code> or <code>header_line</code>. If both <code>set_column_name</code> and <code>header_line</code> are not available, the default column's name is: 0 1 2...</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the text file.</p> </li> <li> <code>header_line</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>the line to extract column-names. Defaults to None.</p> </li> <li> <code>set_column_name</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>Names of columns to extract. Defaults to None.</p> </li> <li> <code>usecols</code>             (<code>tuple</code>, default:                 <code>None</code> )         \u2013          <p>only extract some columns. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>pandas DataFrame</p> </li> </ul>"},{"location":"io/#thamd.io.read_data.logMFD","title":"<code>logMFD(file_name, dim=1) -&gt; pd.DataFrame</code>","text":"<p>Function to read data from LogMFD calculation.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the logmfd.out file.</p> </li> <li> <code>dim</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>dimension of LogMFD calulation. Defaults to 1.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>           \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>pandas DataFrame</p> </li> </ul>"},{"location":"io/#thamd.io.read_data.lammps_var","title":"<code>lammps_var(file_name, var_name=None)</code>","text":"<p>Function to extract variable values from LAMMPS input file.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the text file in LAMMPS input format.</p> </li> <li> <code>var_name</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>list of varibalbes to be extracted. Default to None. mean extract all variables.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ds</code> (            <code>Series</code> )        \u2013          <p>pandas Series contains variable in Lammps file</p> </li> </ul>"},{"location":"io/#thamd.io.read_data.plumed_var","title":"<code>plumed_var(file_name, var_name, block_name=None)</code>","text":"<p>Function to extract variable values from PLUMED input file.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the text file in LAMMPS input format.</p> </li> <li> <code>var_name</code>             (<code>str</code>)         \u2013          <p>list of keyworks in PLUMED, ex: INTERVAL,...</p> </li> <li> <code>block_name</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>block command in Plumed, ex: METAD, LOGMFD. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>value</code> (            <code>float</code> )        \u2013          <p>value of plumed_var.</p> </li> </ul> Quote <p>Include negative decimal numbers in regular expression</p>"},{"location":"io/#thamd.io.read_data.list_matrix_in_dir","title":"<code>list_matrix_in_dir(search_key='deform_', file_ext='.txt', trim_label='', read_note=False, recursive=True)</code>","text":"<p>read data from all *.txt files in current and sub-folders.</p> <p>Parameters:</p> <ul> <li> <code>search_key</code>             (<code>str</code>, default:                 <code>'deform_'</code> )         \u2013          <p>a string to search file_name.</p> </li> <li> <code>file_ext</code>             (<code>str</code>, default:                 <code>'.txt'</code> )         \u2013          <p>file extension. Default to '.txt'</p> </li> <li> <code>trim_label</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>a string to remove from file_name. Default to ''.</p> </li> <li> <code>read_note</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>read 'note' column in pd.DataFrame. Default to False.</p> </li> <li> <code>recursive</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>search in sub-folders. Default to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ldf</code> (            <code>list</code> )        \u2013          <p>list of DataFrames.</p> </li> <li> <code>files</code> (            <code>list</code> )        \u2013          <p>list of filenames.</p> </li> <li> <code>labels</code> (            <code>list</code> )        \u2013          <p>list of labels, which are rest of filename-stems after trimmed by 'trim_label'.</p> </li> </ul>"},{"location":"io/#thamd.io.read_script","title":"<code>read_script</code>","text":"<p>This module contains functions to read some specific scripts.</p>"},{"location":"io/#thamd.io.read_script.lines","title":"<code>lines(file_name, keywords=[])</code>","text":"<p>Function to read lines in a script that match some KEY_WORDs.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>a text file of any format.</p> </li> <li> <code>keywords</code>             (<code>list</code>, default:                 <code>[]</code> )         \u2013          <p>list-of-Keywords to extract a line, ex: METAD, LOGMFD. Default to [], mean read all lines.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>lines</code> (            <code>list</code> )        \u2013          <p>a list of lines.</p> </li> </ul>"},{"location":"io/#thamd.io.read_script.plumed_block","title":"<code>plumed_block(file_name, block_name=' ')</code>","text":"<p>Function to read block_command in PLUMED script.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>a text file of PLUMED format.</p> </li> <li> <code>block_name</code>             (<code>str</code>, default:                 <code>' '</code> )         \u2013          <p>block command in PLUMED, ex: METAD, LOGMFD</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>lines</code> (            <code>list</code> )        \u2013          <p>block_of_commandlines</p> </li> </ul>"},{"location":"io/#thamd.io.write_script","title":"<code>write_script</code>","text":"<p>This module contains functions to write some specific scripts.</p>"},{"location":"io/#thamd.io.write_script.lines","title":"<code>lines(filename, lines)</code>","text":"<p>Funtion to write a list into text file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>file name.</p> </li> <li> <code>lines</code>             (<code>list</code>)         \u2013          <p>list of strings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>file</code> (            <code>obj</code> )        \u2013          </li> </ul>"},{"location":"io/Lmp_Ave_Chunk/","title":"Block Data","text":""},{"location":"io/Lmp_Ave_Chunk/#thamd.io.LmpAveChunk","title":"<code>thamd.io.LmpAveChunk(file_name)</code>","text":"<p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> <p>Attributes:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>file name.</p> </li> <li> <code>frame</code>             (<code>DataFrame</code>)         \u2013          <p>3d pandas Frame (multi-row-index DataFrame).</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>ReadRDF       </code>           \u2013            <p>read RDF file</p> </li> <li> <code>AverageRDF    </code>           \u2013            <p>the Average RDF</p> </li> </ul> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpAveChunk</code> )        \u2013          <p>LmpAveChunk object</p> </li> </ul> <p>Examples:</p> <pre><code>RDF = LmpAveChunk('LmpAveChunk.txt')\n</code></pre>"},{"location":"io/Lmp_Ave_Chunk/#thamd.io.LmpAveChunk.read_AveChunk","title":"<code>read_AveChunk(file_name)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>input RDF file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpAveChunk</code> )        \u2013          <p>LmpAveChunk object</p> </li> </ul>"},{"location":"io/Lmp_Ave_Chunk/#thamd.io.LmpAveChunk.compute_AveChunk","title":"<code>compute_AveChunk()</code>","text":"<p>compute average of RDF over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>Average of RDF</p> </li> </ul>"},{"location":"io/Lmp_Log_File/","title":"Block Data","text":""},{"location":"io/Lmp_Log_File/#thamd.io.LmpLogFile","title":"<code>thamd.io.LmpLogFile(logfile=None)</code>","text":"<p>Create an Object of LOG file.</p> Note <pre><code>run 0 without data\n</code></pre> <p>Parameters:</p> <ul> <li> <code>logfile</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>file_name of LOG file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpLogFile</code> )        \u2013          <p>LmpLogFile object</p> </li> </ul>"},{"location":"io/Lmp_Log_File/#thamd.io.LmpLogFile.read_log","title":"<code>read_log(logfile)</code>","text":"<p>Read LAMMPS logfile Args:         logfile (str): input LOG file</p> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpLogFile</code> )        \u2013          <p>LmpLogFile object</p> </li> </ul>"},{"location":"io/Lmp_RDF/","title":"Block Data","text":""},{"location":"io/Lmp_RDF/#thamd.io.LmpRDF","title":"<code>thamd.io.LmpRDF(file_name)</code>","text":"<p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> <p>Attributes:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>file name</p> </li> <li> <code>frame</code>             (<code>DataFrame</code>)         \u2013          <p>3d pandas Frame (multi-row-index DataFrame)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>ReadRDF       </code>           \u2013            <p>read RDF file</p> </li> <li> <code>AverageRDF    </code>           \u2013            <p>the Average RDF</p> </li> </ul> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpAveChunk</code> )        \u2013          <p>LmpAveChunk object</p> </li> </ul> <p>Examples:</p> <pre><code>RDF = LmpAveChunk('rdf.txt')\n</code></pre>"},{"location":"io/Lmp_RDF/#thamd.io.LmpRDF.read_RDF","title":"<code>read_RDF(file_name)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>input RDF file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>LmpRDF</code> )        \u2013          <p>LmpRDF object</p> </li> </ul>"},{"location":"io/Lmp_RDF/#thamd.io.LmpRDF.compute_AveRDF","title":"<code>compute_AveRDF()</code>","text":"<p>compute average of RDF over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>Average of RDF</p> </li> </ul>"},{"location":"io/Plum_Histogram/","title":"Block Data","text":""},{"location":"io/Plum_Histogram/#thamd.io.PlumHistogram","title":"<code>thamd.io.PlumHistogram(file_name)</code>","text":"<p>Create an Object of DUMP file</p> <p>Methods:</p> <ul> <li> <code>read_histogram       </code>           \u2013            <p>read Histogram file</p> </li> <li> <code>average_histogram    </code>           \u2013            <p>the Average Histogram</p> </li> <li> <code>AreaHisto       </code>           \u2013            <p>Area under pdf curve</p> </li> <li> <code>find_tail</code>           \u2013            <p>find limit of histogram</p> </li> <li> <code>find_center</code>           \u2013            <p>find center of histogram</p> </li> </ul> <p>Examples:</p> <pre><code>RDF = thaFileType.PlumHistogram(file_name='myRDF.txt')\n</code></pre> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>PlumHistogram</code> )        \u2013          <p>PlumHistogram object</p> </li> </ul>"},{"location":"io/Plum_Histogram/#thamd.io.PlumHistogram.read_histogram","title":"<code>read_histogram(file_name)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code> </code>)         \u2013          <p>input HISTOGRAM file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (            <code>PlumHistogram</code> )        \u2013          <p>update PlumHistogram object</p> </li> </ul>"},{"location":"io/Plum_Histogram/#thamd.io.PlumHistogram.compute_average_histogram","title":"<code>compute_average_histogram()</code>","text":"<p>compute average of histogram over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>DataFrame of avergave histogram</p> </li> </ul>"},{"location":"io/Plum_Histogram/#thamd.io.PlumHistogram.areaHisto","title":"<code>areaHisto()</code>","text":""},{"location":"io/Plum_Histogram/#thamd.io.PlumHistogram.fit_std_gaussian","title":"<code>fit_std_gaussian()</code>","text":"<p>Fit the average-histogarm to Standard Gaussian function</p> <p>Returns:</p> <ul> <li> <code>amp, miu, sigma) (tuple</code>         \u2013          <p>parameters of Gaussian function</p> </li> </ul>"},{"location":"io/Plum_Histogram/#thamd.io.PlumHistogram.find_tail","title":"<code>find_tail(tol=0.0001, gridSize=1e-06)</code>","text":"<p>Find tail of distribution function</p> <p>Parameters:</p> <ul> <li> <code>tol</code>             (<code>float</code>, default:                 <code>0.0001</code> )         \u2013          <p>tolerance</p> </li> <li> <code>gridSize</code>             (<code>float</code>, default:                 <code>1e-06</code> )         \u2013          <p>size of grid</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>left_tail</code> (            <code>float</code> )        \u2013          <p>limit on the left side</p> </li> <li> <code>right_tail</code> (            <code>float</code> )        \u2013          <p>limit on the right side</p> </li> </ul>"},{"location":"io/Plum_Histogram/#thamd.io.PlumHistogram.find_center","title":"<code>find_center(gridSize=1e-06)</code>","text":"<p>Find tail of distribution function</p> <p>Parameters:</p> <ul> <li> <code>gridSize</code>             (<code>float</code>, default:                 <code>1e-06</code> )         \u2013          <p>size of grid</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Xcenter</code> (            <code>float</code> )        \u2013          <p>center of the distribution function</p> </li> </ul>"},{"location":"io/define_script/","title":"Define scripts","text":""},{"location":"io/define_script/#thamd.io.define_script","title":"<code>thamd.io.define_script</code>","text":"<p>This module contains functions to define some specific scripts.</p>"},{"location":"io/define_script/#thamd.io.define_script.FCCUBIC_script","title":"<code>FCCUBIC_script(a_fcc, zDirect, label='mcv', alpha=27, partialCompute=False, atoms='@mdatoms', atomsA=None, atomsB=None, options='')</code>","text":"<p>PLUMED script to compute FCCUBIC</p> <p>Parameters:</p> <ul> <li> <code>a_fcc</code>             (<code>float</code>)         \u2013          <p>Lattice constant of FCC crystal</p> </li> <li> <code>zDirect</code>             (<code>str</code>)         \u2013          <p>specify the z-direction of crystal</p> </li> <li> <code>label</code>             (<code>str</code>, default:                 <code>'mcv'</code> )         \u2013          <p>label of PLUMED command</p> </li> <li> <code>alpha</code>             (<code>int</code>, default:                 <code>27</code> )         \u2013          <p>ALPHA parameter to compute FCCUBIC colvar.</p> </li> <li> <code>atoms</code>             (<code>str</code>, default:                 <code>'@mdatoms'</code> )         \u2013          <p>specify atom-ids in computed group.</p> </li> <li> <code>partialCompute</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>compute for some atoms.</p> </li> <li> <code>atomsA</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>specify atom-ids in group A.</p> </li> <li> <code>atomsB</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>specify atom-ids in group B.</p> </li> <li> <code>options</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>add options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list</code> )        \u2013          <p>list of strings.</p> </li> </ul>"},{"location":"io/define_script/#thamd.io.define_script.LOCAL_CRYSTALINITY_script","title":"<code>LOCAL_CRYSTALINITY_script(a_fcc, zDirect, label='mcv', vectors=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], atoms='@mdatoms', options='')</code>","text":"<p>PLUMED script to compute LOCAL_CRYSTALINITY</p> <p>Parameters:</p> <ul> <li> <code>a_fcc</code>             (<code>float</code>)         \u2013          <p>Lattice constant of FCC crystal</p> </li> <li> <code>zDirect</code>             (<code>str</code>)         \u2013          <p>specify the z-direction of crystal</p> </li> <li> <code>label</code>             (<code>str</code>, default:                 <code>'mcv'</code> )         \u2013          <p>label of PLUMED command</p> </li> <li> <code>vectors</code>             (<code>list</code>, default:                 <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )         \u2013          <p>2xN list of lists, to specify directions of reciprocal vectors.</p> </li> <li> <code>atoms</code>             (<code>str</code>, default:                 <code>'@mdatoms'</code> )         \u2013          <p>specify atom-ids in computed group.</p> </li> <li> <code>options</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>add options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list</code> )        \u2013          <p>list of strings.</p> </li> </ul>"},{"location":"io/define_script/#thamd.io.define_script.LOGMFD_script","title":"<code>LOGMFD_script(ARG, FICT, FICT_MIN, FICT_MAX, TEMP, DELTA_T, INTERVAL, KAPPA, deltaF, deltaX, kB, label='mfd', FLOG=5000, MFDstat='VS')</code>","text":"<p>PLUMED script to compute LOGFMD</p> <p>Parameters:</p> <ul> <li> <code>ARG</code>             (<code>str</code>)         \u2013          <p>the scalar input for this action</p> </li> <li> <code>FICT</code>             (<code>float</code>)         \u2013          <p>The initial values of the fictitious dynamical variables</p> </li> <li> <code>FICT_MIN</code>             (<code>float</code>)         \u2013          <p>Boundaries of CV_space</p> </li> <li> <code>FICT_MAX</code>             (<code>float</code>)         \u2013          <p>Boundaries of CV_space</p> </li> <li> <code>TEMP</code>             (<code>float</code>)         \u2013          <p>Temperature of the fictitious dynamical variables</p> </li> <li> <code>DELTA_T</code>             (<code>float</code>)         \u2013          <p>Time step for the fictitious dynamical variables (MFD step)</p> </li> <li> <code>INTERVAL</code>             (<code>int</code>)         \u2013          <p>Period of MD steps ( Nm) to update fictitious dynamical variables</p> </li> <li> <code>KAPPA</code>             (<code>int</code>)         \u2013          <p>Spring constant of the harmonic restraining potential for the fictitious dynamical variables</p> </li> <li> <code>deltaF</code>             (<code>float</code>)         \u2013          <p>Energy Barrier to estimate ALPHA (Alpha parameter for LogMFD)</p> </li> <li> <code>deltaX</code>             (<code>float</code>)         \u2013          <p>CV distance at each MFDstep, to estimate MFICT, VFICT (mass &amp; velocity of fictitious dynamical variable)</p> </li> <li> <code>kB</code>             (<code>float</code>)         \u2013          <p>Boltzmann constant</p> </li> </ul> <pre><code>label (str): label of PLUMED command\n    FLOG (float): The initial free energy value in the LogMFD, initial F(X)\n    MFDstat (str): Type of thermostat for the fictitious dynamical variables. NVE, NVT, VS are available.\n</code></pre> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list</code> )        \u2013          <p>list of strings.</p> </li> </ul>"},{"location":"io/path_tools/","title":"Path tools","text":""},{"location":"io/path_tools/#thamd.io.path_tools","title":"<code>thamd.io.path_tools</code>","text":""},{"location":"io/path_tools/#thamd.io.path_tools.search_path","title":"<code>search_path(search_key, recursive=True)</code>","text":"<p>search files/dirs with specific key</p> <p>Parameters:</p> <ul> <li> <code>search_key</code>             (<code>str</code>)         \u2013          <p>key to search</p> </li> <li> <code>recursive</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>search recursively. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>list-of-str (list): paths to the files/dirs</p> </li> </ul>"},{"location":"io/path_tools/#thamd.io.path_tools.change_pathname","title":"<code>change_pathname(paths, oldString, newString, replace=False)</code>","text":"<p>change path names</p> <p>Parameters:</p> <ul> <li> <code>paths</code>             (<code>list - of - str</code>)         \u2013          <p>paths to the files/dirs</p> </li> <li> <code>oldString</code>             (<code>str</code>)         \u2013          <p>old string in path name</p> </li> <li> <code>newString</code>             (<code>str</code>)         \u2013          <p>new string in path name</p> </li> <li> <code>replace</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>replace the old path name if the new one exists. Defaults to False.</p> </li> </ul>"},{"location":"io/read_data/","title":"Read data","text":""},{"location":"io/read_data/#thamd.io.read_data","title":"<code>thamd.io.read_data</code>","text":"<p>This module contains functions to read numeric data from various formats of TEXT files.</p>"},{"location":"io/read_data/#thamd.io.read_data.matrix_auto","title":"<code>matrix_auto(file_name, header_line=None, set_column_name=None, comment='#', read_note=False) -&gt; pd.DataFrame</code>","text":"<p>Function to read Data that number of values in each line are not equal, ex: p2p binance (missing values) This cannot be read by Numpy, Pandas,...</p> <p>The names of columns are exatract based on <code>set_column_name</code> or <code>header_line</code>. If both <code>set_column_name</code> and <code>header_line</code> are not available, the default column's name is: 0 1 2...</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the text file.</p> </li> <li> <code>header_line</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>the lines to extract column-names. Defaults to None.</p> </li> <li> <code>set_column_name</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>Names of columns to extract. Defaults to None.</p> </li> <li> <code>comment</code>             (<code>str</code>, default:                 <code>'#'</code> )         \u2013          <p>comment-line mark. Defaults to \"#\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>pandas DataFrame</p> </li> </ul> Note <p>To return 2 lists from list comprehension, it is better (may faster) running 2 separated list comprehensions. <code>.strip()</code> function remove trailing and leading space in string.</p>"},{"location":"io/read_data/#thamd.io.read_data.matrix","title":"<code>matrix(file_name, header_line=None, set_column_name=None, usecols=None)</code>","text":"<p>Function to read Data that is as a regular matrix. The names of columns are exatract based on <code>set_column_name</code> or <code>header_line</code>. If both <code>set_column_name</code> and <code>header_line</code> are not available, the default column's name is: 0 1 2...</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the text file.</p> </li> <li> <code>header_line</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>the line to extract column-names. Defaults to None.</p> </li> <li> <code>set_column_name</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>Names of columns to extract. Defaults to None.</p> </li> <li> <code>usecols</code>             (<code>tuple</code>, default:                 <code>None</code> )         \u2013          <p>only extract some columns. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>pandas DataFrame</p> </li> </ul>"},{"location":"io/read_data/#thamd.io.read_data.logMFD","title":"<code>logMFD(file_name, dim=1) -&gt; pd.DataFrame</code>","text":"<p>Function to read data from LogMFD calculation.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the logmfd.out file.</p> </li> <li> <code>dim</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>dimension of LogMFD calulation. Defaults to 1.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>           \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>pandas DataFrame</p> </li> </ul>"},{"location":"io/read_data/#thamd.io.read_data.lammps_var","title":"<code>lammps_var(file_name, var_name=None)</code>","text":"<p>Function to extract variable values from LAMMPS input file.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the text file in LAMMPS input format.</p> </li> <li> <code>var_name</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>list of varibalbes to be extracted. Default to None. mean extract all variables.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ds</code> (            <code>Series</code> )        \u2013          <p>pandas Series contains variable in Lammps file</p> </li> </ul>"},{"location":"io/read_data/#thamd.io.read_data.plumed_var","title":"<code>plumed_var(file_name, var_name, block_name=None)</code>","text":"<p>Function to extract variable values from PLUMED input file.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the text file in LAMMPS input format.</p> </li> <li> <code>var_name</code>             (<code>str</code>)         \u2013          <p>list of keyworks in PLUMED, ex: INTERVAL,...</p> </li> <li> <code>block_name</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>block command in Plumed, ex: METAD, LOGMFD. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>value</code> (            <code>float</code> )        \u2013          <p>value of plumed_var.</p> </li> </ul> Quote <p>Include negative decimal numbers in regular expression</p>"},{"location":"io/read_data/#thamd.io.read_data.list_matrix_in_dir","title":"<code>list_matrix_in_dir(search_key='deform_', file_ext='.txt', trim_label='', read_note=False, recursive=True)</code>","text":"<p>read data from all *.txt files in current and sub-folders.</p> <p>Parameters:</p> <ul> <li> <code>search_key</code>             (<code>str</code>, default:                 <code>'deform_'</code> )         \u2013          <p>a string to search file_name.</p> </li> <li> <code>file_ext</code>             (<code>str</code>, default:                 <code>'.txt'</code> )         \u2013          <p>file extension. Default to '.txt'</p> </li> <li> <code>trim_label</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>a string to remove from file_name. Default to ''.</p> </li> <li> <code>read_note</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>read 'note' column in pd.DataFrame. Default to False.</p> </li> <li> <code>recursive</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>search in sub-folders. Default to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ldf</code> (            <code>list</code> )        \u2013          <p>list of DataFrames.</p> </li> <li> <code>files</code> (            <code>list</code> )        \u2013          <p>list of filenames.</p> </li> <li> <code>labels</code> (            <code>list</code> )        \u2013          <p>list of labels, which are rest of filename-stems after trimmed by 'trim_label'.</p> </li> </ul>"},{"location":"io/read_script/","title":"Read scripts","text":""},{"location":"io/read_script/#thamd.io.read_script","title":"<code>thamd.io.read_script</code>","text":"<p>This module contains functions to read some specific scripts.</p>"},{"location":"io/read_script/#thamd.io.read_script.lines","title":"<code>lines(file_name, keywords=[])</code>","text":"<p>Function to read lines in a script that match some KEY_WORDs.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>a text file of any format.</p> </li> <li> <code>keywords</code>             (<code>list</code>, default:                 <code>[]</code> )         \u2013          <p>list-of-Keywords to extract a line, ex: METAD, LOGMFD. Default to [], mean read all lines.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>lines</code> (            <code>list</code> )        \u2013          <p>a list of lines.</p> </li> </ul>"},{"location":"io/read_script/#thamd.io.read_script.plumed_block","title":"<code>plumed_block(file_name, block_name=' ')</code>","text":"<p>Function to read block_command in PLUMED script.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>a text file of PLUMED format.</p> </li> <li> <code>block_name</code>             (<code>str</code>, default:                 <code>' '</code> )         \u2013          <p>block command in PLUMED, ex: METAD, LOGMFD</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>lines</code> (            <code>list</code> )        \u2013          <p>block_of_commandlines</p> </li> </ul>"},{"location":"io/write_script/","title":"Write scripts","text":""},{"location":"io/write_script/#thamd.io.write_script","title":"<code>thamd.io.write_script</code>","text":"<p>This module contains functions to write some specific scripts.</p>"},{"location":"io/write_script/#thamd.io.write_script.lines","title":"<code>lines(filename, lines)</code>","text":"<p>Funtion to write a list into text file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>file name.</p> </li> <li> <code>lines</code>             (<code>list</code>)         \u2013          <p>list of strings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>file</code> (            <code>obj</code> )        \u2013          </li> </ul>"},{"location":"model/coordinate_tranform/","title":"coordinate_tranform","text":""},{"location":"model/coordinate_tranform/#thamd.model","title":"<code>thamd.model</code>","text":""},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform","title":"<code>CoordTransform(old_orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], new_orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]])</code>","text":"<p>We can express a rotation using direction-cosines-matrix (DCM) or Euler-angles (phi,theta,psi)</p> <p>Parameters:</p> <ul> <li> <code>old_orient</code>             (<code>array / list</code>, default:                 <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )         \u2013          <p>3x3 array/list, contains 3 mutully orthotropic unit vectors of the OLD basis</p> </li> <li> <code>new_orient</code>             (<code>array / list</code>, default:                 <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )         \u2013          <p>3x3 array/list, contains 3 mutully orthotropic unit vectors of the NEW basis             (all input vector will be normalized to unit vectors)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>obj</code> (            <code>obj</code> )        \u2013          <p>3x3 array, the rotation matrix or matrix of direction cosines</p> </li> </ul> <p>Examples:</p> <pre><code>oldAxis = array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\nnewAxis = array([[1, -1, 0], [1, 1, -2], [1, 1, 1]])\nBT = thamd.CoordTransform(old_orient=oldAxis, new_orient=newAxis)\n</code></pre> Refs <ol> <li>Bower, Allan F. Applied Mechanics of Solids. CRC Press, 2009. page 711</li> <li>https://link.aps.org/doi/10.1103/PhysRevB.92.180102</li> <li>https://en.wikipedia.org/wiki/Euler_angles</li> </ol>"},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform.old_orient","title":"<code>old_orient = asarray(old_orient)</code>  <code>instance-attribute</code>","text":""},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform.new_orient","title":"<code>new_orient = asarray(new_orient)</code>  <code>instance-attribute</code>","text":""},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform.DCM","title":"<code>DCM = None</code>  <code>instance-attribute</code>","text":""},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform.ROT","title":"<code>ROT = None</code>  <code>instance-attribute</code>","text":""},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform.EA","title":"<code>EA = None</code>  <code>instance-attribute</code>","text":""},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform.direction_cosine_matrix","title":"<code>direction_cosine_matrix()</code>","text":"<p>Calculate direction-cosines-matrix (DCM) between 2 coordinates systems</p> <p>Returns:</p> <ul> <li> <code>Q</code>        \u2013          <p>3x3 array, the rotation matrix or matrix of direction cosines</p> </li> </ul> <p>Examples:</p> <pre><code>BT = thamd.CoordTransform(old_orient=oldAxis, new_orient=newAxis)\nQ = BT.direction_cosine_matrix()\n</code></pre>"},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform.rotation_matrix","title":"<code>rotation_matrix()</code>","text":"<p>Calculate Rotation-matrix (R) as transpose of DCM By Cao Thang, Apr 2019,  Update: May2020</p>"},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform.EA2ROT","title":"<code>EA2ROT(euler_angle, unit='rad')</code>","text":"<p>Calculate Rotation_Matrix Euler Angles (EA) between 2 coordinates systems (ZXZ proper Euler angles) This is just for testing, since we dont know whether input angles yield orthogonal axis or not</p> <p>Parameters:</p> <ul> <li> <code>euler_angle</code>             (<code>list</code>)         \u2013          <p>1x3 array/list (phi,theta,psi) in Rad or Deg</p> </li> <li> <code>unit</code>             (<code>str</code>, default:                 <code>'rad'</code> )         \u2013          <p>'rad' or 'deg'      (default is rad)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Q</code> (            <code>array</code> )        \u2013          <p>3x3 array, the rotation matrix or matrix of direction cosines</p> </li> </ul> <p>Examples:</p> <pre><code>BT = thamd.CoordTransform()\nDCM = BT.EulerAngle(euler_angle=[90,], unit='deg')\n</code></pre> Note <p>don't use arctan2()</p>"},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform.euler_angle","title":"<code>euler_angle(unit='rad')</code>","text":"<p>Calculate Euler Angles (EA) between 2 coordinates systems (intrinsic ZXZ proper Euler angles) https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.as_euler.html#r72d546869407-1</p> <p>Parameters:</p> <ul> <li> <code>unit='rad'</code>         \u2013          <p>'rad' or 'deg'      (default is rad)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Angle</code>        \u2013          <p>1x3 array (phi,theta,psi) in Rad  (apply intrinsic ZXZ proper Euler)</p> </li> </ul> <p>Examples:</p> <p>BT = thamd.CoordTransform(old_orient=oldAxis, new_orient=newAxis) phi,theta,psi = BT.EulerAngle(unit='deg')</p> Note <ul> <li>don't use arctan2()</li> <li>Rotation Matrix is as to tranpose of DCM, use Rotation Matrix to compute EA</li> <li>To avoid devide by zero, we use 1e-64 instead of 0.</li> </ul>"},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform.euler_angle_PSpincal","title":"<code>euler_angle_PSpincal(euler_order='zxz', unit='rad', tol=1e-07)</code>","text":"<p>Calculate Euler Angles (EA) between 2 coordinates systems (proper Eulerian angles)</p> <p>Parameters:</p> <ul> <li> <code>unit</code>         \u2013          <p>'rad', 'deg'      (default is rad)</p> </li> <li> <code>euler_order='zxz'</code>         \u2013          <p>rotation order, lowercase [\"zyx\",\"zxy\",\"yxz\",\"xzy\",\"xyz\",\"yzx\",\"zyz\",\"zxz\",\"yxy\",\"yzy\",\"xyx\",\"xzx\"]</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Angle</code>        \u2013          <p>1x3 array (phi,theta,psi) in Rad  (apply extrinsic ZXZ proper Euler)</p> </li> </ul> Note <ul> <li>this module may define psi as phi, and vice versa. So becareful</li> <li>should not use PSpincalc, since it produce unknown value?</li> </ul> Refs <p>[1] navpy not use 'ZXZ': https://navpy.readthedocs.io/en/latest/code_docs/coordinate_transformations.html [2] use this https://pypi.org/project/PSpincalc/ [3] https://github.com/tuxcell/PSpincalc/blob/master/PSpincalc/PSpincalc.py     Ex: https://github.com/tuxcell/PSpincalc/blob/master/examples/examplesPSpincalc.ipynb</p>"},{"location":"model/coordinate_tranform/#thamd.model.CoordTransform.rotate_3d","title":"<code>rotate_3d(points)</code>","text":"<p>Rotate a set of points (or set of vectors) from a OLD-coords to NEW-coords</p> <p>Parameters:</p> <ul> <li> <code>points</code>         \u2013          <p>Nx3 array, contain coords in OLD coordinates systems</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>points</code>        \u2013          <p>Nx3 array, contain coords in NEW coordinates systems</p> </li> </ul> <p>Examples:</p> <pre><code>BT = thamd.CoordTransform(old_orient=oldAxis, new_orient=newAxis)\nnewP = BT.rotate_3d(P)\n</code></pre>"},{"location":"model/coordinate_tranform/#thamd.model.box_orientation","title":"<code>box_orientation(box_size=[1, 1, 1], zDirect='001', xDirect=None)</code>","text":"<p>covert Orirentation and length of simulation box.</p> <p>Parameters:</p> <ul> <li> <code>box_size</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>dimension of box on each side as in [100] direction</p> </li> <li> <code>zDirect</code>             (<code>str</code>, default:                 <code>'001'</code> )         \u2013          <p>specify the direction of z-side. Defaults to '001', mean nothing is happen.</p> </li> <li> <code>xDirect</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>specify the direction of z-side.  Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>newOrient</code> (            <code>list</code> )        \u2013          <p>list-of-vectors of 3 directional vectors.</p> </li> <li> <code>box_size</code> (            <code>tuple</code> )        \u2013          <p>dimension of box on each side.</p> </li> </ul> <p>Examples:</p>"},{"location":"model/coordinate_tranform/#thamd.model.rot1axis","title":"<code>rot1axis(P, theta, axis='X')</code>","text":"<p>Rotate array of points about 1 axis</p> <p>Parameters:</p> <ul> <li> <code>P</code>             (<code> </code>)         \u2013          <p>Nx3 array, contain input poits</p> </li> <li> <code>theta</code>             (<code> </code>)         \u2013          <p>the rotation angle in Degree</p> </li> <li> <code>axis</code>             (<code> </code>, default:                 <code>'X'</code> )         \u2013          <p>Rotation axis</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>outP</code>        \u2013          <p>Nx3 array, contain points after rotation</p> </li> </ul>"},{"location":"model/coordinate_tranform/#thamd.model.check_right_hand","title":"<code>check_right_hand(list_3vec=[[1, 0, 0], [0, 1, 0], [0, 0, 1]])</code>","text":"<p>check right_hand_rule orthogonal of 3 vectors</p>"},{"location":"model/coordinate_tranform/#thamd.model.guess_right_hand","title":"<code>guess_right_hand(list_2vec=[[1, 0, 0], [0, 1, 0]])</code>","text":"<p>give 2 vectors, then guess the third vector that satisfy right_hand_rule</p>"},{"location":"model/coordinate_tranform/#thamd.model.cartesian2spherical","title":"<code>cartesian2spherical(xyz)</code>","text":"<p>Convert cartesian coordinates to Spherical coordinates</p> <p>Parameters:</p> <ul> <li> <code>xyz</code>             (<code>array</code>)         \u2013          <p>Mx3 array contain Cartesian coordinates (X, Y, Z)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>shpCoord</code> (            <code>array</code> )        \u2013          <p>Mx3 array contain Spherical coordinates (R, theta, phi). Also (radial distance, polar angle, azimuthal(longitude) angle)</p> </li> </ul> Note <pre><code>    1. The polar(theta) angle defined from from Z-axis down (zero at the North pole to 180\u00b0 at the South pole)\n    2. adapted from [this](https://stackoverflow.com/questions/4116658/faster-numpy-cartesian-to-spherical-coordinate-conversion)\n</code></pre> <p>Info</p> <pre><code>    There are many conventions that angles can be\n            - In geography, angles are in latitude/longitude or elevation/azimuthal form, polar angle is called [`latitude`](https://en.wikipedia.org/wiki/Latitude), measuze from XY-plane (ranges from -90\u00b0 at the south pole to 90\u00b0 at the north pole, with 0\u00b0 at the Equator)\n\n            ![](https://upload.wikimedia.org/wikipedia/commons/thumb/8/8c/Latitude_and_longitude_graticule_on_an_ellipsoid.svg/200px-Latitude_and_longitude_graticule_on_an_ellipsoid.svg.png)\n\n            - In mathematics and physics, polar angle measured from Z-axis (zero at the North pole to 180\u00b0 at the South pole)\n\n            ![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4f/3D_Spherical.svg/360px-3D_Spherical.svg.png)\n\n            - In `scipy`, polar angle is defined as [Colatitude](https://en.wikipedia.org/wiki/Colatitude), which is a non-negative quantity, ranging from zero at the North pole to 180\u00b0 at the South pole (same as commonly used in mathematics and physics)\n</code></pre>"},{"location":"model/coordinate_tranform/#thamd.model.add_periodic_image","title":"<code>add_periodic_image(points, box, bound_cond=[1, 1, 1], cutoff=6.5)</code>","text":"<p>Function to add \"Periodic Images\" of atoms at Periodic Boundaries (with a specific cutoff distance) By Thang, June 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>points</code>             (<code>2d-list np.array pd.DataFrame</code>)         \u2013          <p>Mx3 Matrix contain positions of atoms before Wrapping</p> </li> <li> <code>box</code>             (<code>3d-list array</code>)         \u2013          <p>3x2 Matrix contain simulation box bounds</p> </li> <li> <code>bound_cond</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>1x3 list contains convention of Peridic bounds(ex: bound_cond = [1 1 1])</p> </li> <li> <code>cutoff</code>             (<code>float</code>, default:                 <code>6.5</code> )         \u2013          <p>Cutoff distance</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>contains original atoms and image atoms with remark colum df['image'].</p> </li> </ul> <p>Examples:</p> <p>```py</p> <pre><code>df = add_periodic_image(P, box, bound_cond=[1 1 0], cutoff=5)\n    ```\n</code></pre>"},{"location":"model/coordinate_tranform/#thamd.model.wrap_coord_PBC","title":"<code>wrap_coord_PBC(points, box, bound_cond=[1, 1, 1])</code>","text":"<p>Function to wrap atom positions at Periodic Boundaries By Thang, June 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>points</code>             (<code>2d-list np.array pd.DataFrame</code>)         \u2013          <p>Mx3 Matrix contain positions of atoms before Wrapping</p> </li> <li> <code>box</code>             (<code>3d-list array</code>)         \u2013          <p>3x2 Matrix contain simulation box bounds</p> </li> <li> <code>bound_cond</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>1x3 list contains convention of Peridic bounds(ex: bound_cond = [1 1 1])</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>contains atom positions.</p> </li> </ul> <p>Examples:         <code>py     df = wrap_coord_PBC(P, box, bound_cond=[1 1 0], cutoff=5)</code></p>"},{"location":"model/crystalline/","title":"crystalline","text":""},{"location":"model/crystalline/#thamd.model.D3crystal","title":"<code>thamd.model.D3crystal</code>","text":""},{"location":"model/crystalline/#thamd.model.D3crystal.lattice_orthoRHOMBIC","title":"<code>lattice_orthoRHOMBIC(crystal_type, lattice_constant, orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], size=[1, 1, 1], bound_cond=[1, 1, 1], tol_on_bound=0.1)</code>","text":"<p>Function to create atomic coordinates for crystal model</p> <p>Parameters:</p> <ul> <li> <code>crystal_type</code>             (<code>str</code>)         \u2013          <p>'V2O5', 'FCC', 'BCC'</p> </li> <li> <code>lattice_constant</code>             (<code>list</code>)         \u2013          <p>lattice constant [a,b,c] corresponding to [x,y,z]</p> </li> <li> <code>orient</code>             (<code>list</code>, default:                 <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )         \u2013          <p>3x3 array, contain direction vectors define crystal orientation, ex: ([[1,0,0], [0,1,0], [0,0,1]])</p> </li> <li> <code>size</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>[Nx Ny Nz] 1x3 array, size of model, Nx is X-size in lattice constant unit</p> </li> <li> <code>bound_cond</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>1x3 array contain convention for boundary conditions: 1 is peridic; 0 is not</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>points</code> (            <code>array</code> )        \u2013          <p>Nx3 array contain positions of atoms.</p> </li> <li> <code>box</code> (            <code>array</code> )        \u2013          <p>3x2 array contain size of box contain lattice ([[xlo, xhi], [ylo, yhi], [zlo, zhi]])</p> </li> <li> <code>unit_box</code> (            <code>array</code> )        \u2013          <p>3x2 array contain size of unit cell</p> </li> </ul>"},{"location":"model/crystalline/#thamd.model.D3crystal.lattice_CUBIC","title":"<code>lattice_CUBIC(crystal_type, lattice_constant, orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], size=[1, 1, 1], bound_cond=[1, 1, 1], tol_on_bound=0.1)</code>","text":"<p>Shortcut to create CUBIC crystal, as subclass of ortthoRHOMBIC</p> <p>Parameters:</p> <ul> <li> <code>crystal_type</code>             (<code>str</code>)         \u2013          <p>'FCC', 'BCC'</p> </li> <li> <code>lattice_constant</code>             (<code>float</code>)         \u2013          <p>lattice constant a</p> </li> <li> <code>orient</code>             (<code>list</code>, default:                 <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )         \u2013          <p>3x3 array, contain direction vectors define crystal orientation, ex: ([[1,0,0], [0,1,0], [0,0,1]])</p> </li> <li> <code>size</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>[Nx Ny Nz] 1x3 array, size of model, Nx is X-size in lattice constant unit</p> </li> <li> <code>bound_cond</code>             (<code>list</code>, default:                 <code>[1, 1, 1]</code> )         \u2013          <p>1x3 array contain convention for boundary conditions: 1 is peridic; 0 is not</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>points</code> (            <code>array</code> )        \u2013          <p>Nx3 array contain positions of atoms.</p> </li> <li> <code>box</code> (            <code>array</code> )        \u2013          <p>3x2 array contain size of box contain lattice ([[xlo, xhi], [ylo, yhi], [zlo, zhi]])</p> </li> <li> <code>unit_box</code> (            <code>array</code> )        \u2013          <p>3x2 array contain size of unit cell</p> </li> </ul>"},{"location":"model/crystalline/#thamd.model.D2haxagonal","title":"<code>thamd.model.D2haxagonal</code>","text":""},{"location":"model/crystalline/#thamd.model.D2haxagonal.lattice_Graphene","title":"<code>lattice_Graphene(m, n, bond_CC=1.421, sheet_size=[1, 1], sheet_number=1, layer_bond=3.35, basis_atom='AB')</code>","text":"<p>Calculates the 3D Cartesian coordinates of atoms of (n,m)graphene sheet/ Graphite</p> <p>thangckt, Nov 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>n</code>             (<code>int</code>)         \u2013          <p>Chiral indices n&gt;=m&gt;=0</p> </li> <li> <code>m</code>             (<code>int</code>)         \u2013          <p>Chiral indices n&gt;=m&gt;=0</p> </li> <li> <code>bond_CC</code>             (<code>float</code>, default:                 <code>1.421</code> )         \u2013          <p>Length of C-C bonds</p> </li> <li> <code>sheet_size</code>             (<code>list</code>, default:                 <code>[1, 1]</code> )         \u2013          <p>[Xsize, Ysize], size of graphene sheet</p> </li> <li> <code>sheet_number</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>number of sheets</p> </li> <li> <code>layer_bond</code>             (<code>float</code>, default:                 <code>3.35</code> )         \u2013          <p>Length of plane-plane bonds</p> </li> <li> <code>basis_atom</code>             (<code>str</code>, default:                 <code>'AB'</code> )         \u2013          <p>'AB'/'A'/'B': to create semi-Graphene lattice for adoptting Hydrogen atoms - 'AB': full Garaphene-like crystal - 'A': semi Graphene-like with atom at A-position - 'B': semi Graphene-like with atom at B-position</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>Nx3 array, contain positions of atoms of 1 units cell of (n,m)graphene sheet.</p> </li> <li> <code>box</code> (            <code>array</code> )        \u2013          <p>Simulation box</p> </li> <li> <code>param</code> (            <code>dict</code> )        \u2013          <p>dict contains characteristic parameters of graphene lattice. 'Chiral_len' (float): length of Translational unit vector, corresponding to length on Y direction 'Translate_len' (float): length of Chiral vector, corresponding to length on X direction 'Chiral_ang' (float): Chiral angle of Graphene sheet in Degree. 'Chiral_vector' (array): Chiral vector 'Translate_vector' (array): translations vector</p> </li> </ul> <p>Notes         <pre><code>n=1, m=0 : is the unit cell for Zigzag\nn=1, m=1 : is the unit cell for Armchair\nn&gt;m      : unit cell is automatically computed\n</code></pre></p>"},{"location":"model/crystalline/#thamd.model.D1tube","title":"<code>thamd.model.D1tube</code>","text":""},{"location":"model/crystalline/#thamd.model.D1tube.lattice_CNT","title":"<code>lattice_CNT(m, n, bond_CC=1.421, aspect=1, basis_atom='AB')</code>","text":"<p>Calculates the 3D Cartesian coordinates of atoms of of (n,m) CNT.</p> <p>thangckt, Aug 2022</p> <p>Parameters:</p> <ul> <li> <code>n,m</code>             (<code>int</code>)         \u2013          <p>Chiral indices n&gt;=m&gt;=0</p> </li> <li> <code>bond_CC</code>             (<code>float</code>, default:                 <code>1.421</code> )         \u2013          <p>Length of C-C bonds</p> </li> <li> <code>aspect</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>The nanotube aspect ratio L/D.</p> </li> <li> <code>basis_atom</code>             (<code>str</code>, default:                 <code>'AB'</code> )         \u2013          <p>'AB'/'A'/'B': to create semi-Graphene lattice for adoptting Hydrogen atoms  - 'AB': full Garaphene-like crystal  - 'A': semi Graphene-like with atom at A-position  - 'B': semi Graphene-like with atom at B-position</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (            <code>DataFrame</code> )        \u2013          <p>Nx3 array, contain positions of atoms of 1 units cell of (n,m)graphene sheet.</p> </li> <li> <code>box</code> (            <code>array</code> )        \u2013          <p>Simulation box</p> </li> <li> <code>param</code> (            <code>dict</code> )        \u2013          <p>dict contains characteristic parameters of graphene lattice. 'Chiral_len' (float): length of Translational unit vector, corresponding to length on Y direction 'Translate_len' (float): length of Chiral vector, corresponding to length on X direction 'Chiral_ang' (float): Chiral angle of Graphene sheet in Degree. 'Chiral_vector' (array): Chiral vector 'Translate_vector' (array): translations vector</p> </li> </ul> <p>Notes         <pre><code>n=1, m=0 : is the unit cell for Zigzag\nn=1, m=1 : is the unit cell for Armchair\nn&gt;m      : unit cell is automatically computed\n</code></pre></p>"},{"location":"model/crystalline/#thamd.model.shells_fcc","title":"<code>thamd.model.shells_fcc(a)</code>","text":"<p>Compute nearest-neighbor shells for FCC crystal</p> <p>Parameters:</p> <ul> <li> <code>a</code>             (<code>float</code>)         \u2013          <p>lattice constant</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>shell</code> (            <code>list</code> )        \u2013          <p>5 nearest-neighbor shells</p> </li> </ul>"},{"location":"model/forcefield_info/","title":"forcefield_info","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info","title":"<code>thamd.model.forcefield_info</code>","text":"<p>This module contains some data for various ForceField. Data obtained from simulation</p>"},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM","title":"<code>EAM(atom_symbol, force_field, model_type='BULK', zDirect='001', thickness=20)</code>","text":"<p>Create an Object (class) of Potential, contain some pre-setup information</p> <pre><code>    - Cu: Mishin2001,  Mendelev2008, Foiles1986\n</code></pre> <ul> <li>Al: Laird2000,  Mishin1999,  Mendelev2008,  LiuEA2004, Sheng2011</li> <li>V:  Olsson2009</li> </ul> <p>Parameters:</p> <ul> <li> <code>atom_symbol</code>             (<code>str</code>)         \u2013          <p>define element, e.g., 'Al', 'Cu',...</p> </li> <li> <code>force_field</code>             (<code>str</code>)         \u2013          <p>the name of potential 'Cu' : 'Mishin-2001'; 'Foiles-1986';... 'Al' : 'Mishin-1999'; 'Sheng-2011';...</p> </li> <li> <code>model_type</code>             (<code>str</code>, default:                 <code>'BULK'</code> )         \u2013          <p>type of model (BULK or PLATE)</p> </li> <li> <code>zDirect</code>             (<code>str</code>, default:                 <code>'001'</code> )         \u2013          <p>define the crystal orient along the z-direction simulation box, e,g., '001'/ '110'/ '111'</p> </li> <li> <code>thickness</code>             (<code>int</code>, default:                 <code>20</code> )         \u2013          <p>define thickness in case <code>model_type=PALTE</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>obj</code>        \u2013          </li> </ul> <p>Attributes:</p> <ul> <li> <code>atom_symbol</code>             (<code>str</code>)         \u2013          <p>element</p> </li> <li> <code>force_field</code>             (<code>str</code>)         \u2013          <p>forcefield name.</p> </li> <li> <code>cutoff</code>             (<code>float</code>)         \u2013          <p>return cutoff of forcefield.</p> </li> <li> <code>thermal_coeff</code>             (<code>list</code>)         \u2013          <p>return values thermal expansion coefficients of input Structure</p> </li> </ul> <p>Stored DATA (these data are compute from several simulations, or from papers)</p>"},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.coeff_FCCUBIC_liqsol_coexist","title":"<code>coeff_FCCUBIC_liqsol_coexist = [-0.000467305786, 0.88174401]</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.coeff_FCCUBIC_tail_solid","title":"<code>coeff_FCCUBIC_tail_solid = [-0.0017082985, 1.80537817]</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.coeff_FCCUBIC_tail_liquid","title":"<code>coeff_FCCUBIC_tail_liquid = [-9.33394967e-06, 0.608209715]</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.atom_symbol","title":"<code>atom_symbol = atom_symbol</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.force_field","title":"<code>force_field = force_field</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.thermal_coeff","title":"<code>thermal_coeff = D[thermal_key]</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.cutoff","title":"<code>cutoff = Rcut</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.melt_barrier_coeff","title":"<code>melt_barrier_coeff = melt_barrier[melt_barrier_key]</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.lattice_constant","title":"<code>lattice_constant(temp)</code>","text":"<p>Compute lattice constant at a specific temperature T.</p> <p>Parameters:</p> <ul> <li> <code>temp</code>             (<code>float</code>)         \u2013          <p>input temperature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>a</code> (            <code>float</code> )        \u2013          <p>lattice constant as input temperature.</p> </li> </ul>"},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.atomic_volume_FCC","title":"<code>atomic_volume_FCC(temp)</code>","text":"<p>Compute atomic volume at a specific temperature T.</p> <p>Parameters:</p> <ul> <li> <code>temp</code>             (<code>float</code>)         \u2013          <p>input temperature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>V</code> (            <code>float</code> )        \u2013          <p>atomic volume (volume/atom) as input temperature.</p> </li> </ul>"},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.melt_barrier","title":"<code>melt_barrier(temp)</code>","text":"<p>Compute free energy barrier/atom of melting. For a system of N atoms  \\(F = f*N^(2/3)\\) , then barrier/atom  \\(f = F/N^(2/3)\\). This method return f(T)</p> <p>Parameters:</p> <ul> <li> <code>temp</code>             (<code>float</code>)         \u2013          <p>input temperature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>barrier</code> (            <code>float</code> )        \u2013          <p>free energy barrier/atom of melting as input temperature.</p> </li> </ul>"},{"location":"model/forcefield_info/#thamd.model.forcefield_info.EAM.estimate_FCCUBIC_liqsol","title":"<code>estimate_FCCUBIC_liqsol(temp)</code>","text":"<p>Estimate value of FCCUBIC parameter in bulk solid/liquid at a specific temperature T.</p>"},{"location":"model/forcefield_info/#thamd.model.forcefield_info.ReaxFF","title":"<code>ReaxFF(atom_symbol, force_field, model_type='BULK', zDirect='001')</code>","text":"<p>Create an Object (class) of Potential, contain some pre-setup information</p>"},{"location":"model/forcefield_info/#thamd.model.forcefield_info.ReaxFF.atom_symbol","title":"<code>atom_symbol = atom_symbol</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.ReaxFF.force_field","title":"<code>force_field = force_field</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.ReaxFF.thermal_coeff","title":"<code>thermal_coeff = D[thermal_key]</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.ReaxFF.cutoff","title":"<code>cutoff = Rcut</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.ReaxFF.melt_barrier_coeff","title":"<code>melt_barrier_coeff = melt_barrier[melt_barrier_key]</code>  <code>instance-attribute</code>","text":""},{"location":"model/forcefield_info/#thamd.model.forcefield_info.ReaxFF.lattice_constant","title":"<code>lattice_constant(Temp)</code>","text":""},{"location":"model/pair_LJ/","title":"pair_LJ","text":""},{"location":"model/pair_LJ/#thamd.model.pair_LJ","title":"<code>thamd.model.pair_LJ(dict_group1, dict_group2, unit_style, combining_rule='geometric', pair_style='lj/cut')</code>","text":"<p>compute parameters (epsilon &amp; sigma) of LJ potential at interface Note that in LAMMPS: 'Lorentz_Berthelot'='arithmetic'   https://tinyurl.com/yzpwg2hs</p> <p>Parameters:</p> <ul> <li> <code>dict_group1,</code>             (<code>dict_group2</code>)         \u2013          <p>Dicts contain sig &amp; eps of each element of 2 surfaces. Must contain keys: 'atom_name', 'type', 'sigma', 'epsilon'</p> </li> <li> <code>unit_style</code>         \u2013          <p>'real' or 'metal'</p> </li> </ul> <pre><code>combining_rule='arithmetic' (also 'Lorentz_Berthelot')\n            + 'arithmetic'/'Lorentz_Berthelot'\n            + 'geometric'\n            + 'sixthpower'\n        pair_style='lj/cut': pair_style of Lammps  lj/cut/coul/long\n        external_interaction: require\n</code></pre> Return <p>list-of-string: contain pair_coeffs for LAMMPS</p> Note <pre><code>    energy unit is kcal/mol, but in OPLSaa of Foyer is kJ/mol.\n    types in 2 dict must either completely different or indentical\n</code></pre> <p>Example: PMMA/h_BN interface <pre><code>dict_group1 = {'element':['CT','CT','CT','CT','HC','HC','C_2','O_2','OS','CT','HC'],\n        'atom_name':['opls_135','opls_136','opls_137','opls_139','opls_140','opls_282','opls_465','opls_466','opls_467','opls_468','opls_469'],\n        'type':[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n        'sigma': [3.5, 3.5, 3.5, 3.5, 2.5, 2.42, 3.75, 2.96, 3.0, 3.5, 2.42],\n        'epsilon':[0.066, 0.066, 0.066, 0.066, 0.03, 0.015, 0.105, 0.21, 0.17, 0.066, 0.015]}\ndict_group2 = {'element':['B','N'],\n                'atom_name':['B','N'],\n                'type':[12,13],\n                'sigma': [3.453, 3.365],\n                'epsilon':[0.094988, 0.1448671]}\ncombining_LJ(dict_group1, dict_group2, combining_rule='Lorentz_Berthelot', pair_style='lj/cut/coul/long')\n</code></pre></p>"},{"location":"model/polymer/","title":"polymer","text":""},{"location":"model/polymer/#thamd.model.polymer_mbuild","title":"<code>thamd.model.polymer_mbuild</code>","text":"<p>This module contains classes and functions to build models of atomic polymers See this Python package: [1] mBuild: https://mbuild.mosdef.org/en/stable/</p> <p>See the files: D:\\code\\code_simulate\\polymer_c21_pickup_hBN_PMMA ef_using_mBuild_foyer.ipynb</p> NOTEs <ol> <li>Due to mbuild cannot be installed with python 3.10, so import this package in functions to avoid checking in thamd</li> </ol>"},{"location":"model/polymer/#thamd.model.polymer_mbuild.PMMA_chain","title":"<code>PMMA_chain(chain_len)</code>","text":"<p>build polyPMMA from monomers</p> <p>Parameters:</p> <ul> <li> <code>chain_len</code>             (<code>int</code>)         \u2013          <p>number of monomers in each polymer = degree of polymerization</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>chain</code> (            <code>compound</code> )        \u2013          <p>polymer chain</p> </li> </ul>"},{"location":"model/polymer/#thamd.model.polymer_mbuild.PVC_chain","title":"<code>PVC_chain(chain_len)</code>","text":""},{"location":"model/polymer/#thamd.model.polymer_mbuild.packing_lammps","title":"<code>packing_lammps(chain, chain_num, density=None, box_size=None, forcefield_name=None, forcefield_files=None, atom_style='full', unit_style='metal', combining_rule='geometric', file_name='polymer.dat')</code>","text":"<p>Packing polymer chains into box, and write LAMMPS file Packing based on either density or box_size.</p> <p>Parameters:</p> <ul> <li> <code>chain</code>             (<code>compound</code>)         \u2013          <p>polymer chain</p> </li> <li> <code>chain_num</code>             (<code>int</code>)         \u2013          <p>number of chains to be packed.</p> </li> <li> <code>density</code>             (<code>float</code>, default:                 <code>None</code> )         \u2013          <p>density, unit in kg/m3 (= 1e-3 g/cm3)</p> </li> <li> <code>box_size</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>box_size = [3,3,3]</p> </li> <li> <code>forcefield_name</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>should be 'oplsaa'.</p> </li> <li> <code>forcefield_files</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>path to the *.xml file.</p> </li> <li> <code>atom_style</code>             (<code>str</code>, default:                 <code>'full'</code> )         \u2013          <p>atom_style of LAMMPS.</p> </li> <li> <code>unit_style</code>             (<code>str</code>, default:                 <code>'metal'</code> )         \u2013          <p>can be 'metal'/'real'/'lj'</p> </li> </ul>"},{"location":"model/polymer/#thamd.model.polymer_pysimm","title":"<code>thamd.model.polymer_pysimm</code>","text":"<p>This module contains classes to build models of atomic polymers See this Python package: [1] pysimm: A python package for simulation of molecular systems, 10.1016/j.softx.2016.12.002 source code: https://github.com/polysimtools/pysimm</p>"}]}